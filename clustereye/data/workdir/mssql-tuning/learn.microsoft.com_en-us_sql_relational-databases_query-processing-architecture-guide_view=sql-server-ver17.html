 <!DOCTYPE html>
		<html
			class="layout layout-holy-grail   show-table-of-contents conceptual show-breadcrumb default-focus"
			lang="en-us"
			dir="ltr"
			data-authenticated="false"
			data-auth-status-determined="false"
			data-target="docs"
			x-ms-format-detection="none"
		>
			
		<head>
			<title>Query Processing Architecture Guide - SQL Server | Microsoft Learn</title>
			<meta charset="utf-8" />
			<meta name="viewport" content="width=device-width, initial-scale=1.0" />
			<meta name="color-scheme" content="light dark" />

			<meta name="description" content="How SQL Server processes queries and optimizes query reuse through execution plan caching." />
			<link rel="canonical" href="https://learn.microsoft.com/en-us/sql/relational-databases/query-processing-architecture-guide?view=sql-server-ver17" /> 

			<!-- Non-customizable open graph and sharing-related metadata -->
			<meta name="twitter:card" content="summary_large_image" />
			<meta name="twitter:site" content="@MicrosoftLearn" />
			<meta property="og:type" content="website" />
			<meta property="og:image:alt" content="Microsoft Learn" />
			<meta property="og:image" content="https://learn.microsoft.com/en-us/media/open-graph-image.png" />
			<!-- Page specific open graph and sharing-related metadata -->
			<meta property="og:title" content="Query Processing Architecture Guide - SQL Server" />
			<meta property="og:url" content="https://learn.microsoft.com/en-us/sql/relational-databases/query-processing-architecture-guide?view=sql-server-ver17" />
			<meta property="og:description" content="How SQL Server processes queries and optimizes query reuse through execution plan caching." />
			<meta name="platform_id" content="3ecb2f23-d362-432e-2e86-d30969177979" /> <meta name="scope" content="sql" />
			<meta name="locale" content="en-us" />
			 <meta name="adobe-target" content="true" /> 
			<meta name="uhfHeaderId" content="MSDocsHeader-DocsSQL" />

			<meta name="page_type" content="conceptual" />

			<!--page specific meta tags-->
			

			<!-- custom meta tags -->
			
		<meta name="toc_preview" content="true" />
	
		<meta name="feedback_system" content="Standard" />
	
		<meta name="feedback_product_url" content="https://feedback.azure.com/d365community/forum/04fe6ee0-3b25-ec11-b6e6-000d3a4f0da0" />
	
		<meta name="feedback_help_link_url" content="https://learn.microsoft.com/answers/tags/191/sql-server" />
	
		<meta name="feedback_help_link_type" content="get-help-at-qna" />
	
		<meta name="recommendations" content="true" />
	
		<meta name="manager" content="jroth" />
	
		<meta name="breadcrumb_path" content="../breadcrumb/toc.json" />
	
		<meta name="monikerRange" content="=azuresqldb-current || &gt;=sql-server-2016 || &gt;=sql-server-linux-2017 || =azuresqldb-mi-current || =fabric-sqldb" />
	
		<meta name="ms.update-cycle" content="1825-days" />
	
		<meta name="author" content="MikeRayMSFT" />
	
		<meta name="ms.author" content="mikeray" />
	
		<meta name="ms.reviewer" content="maghan, randolphwest, derekw" />
	
		<meta name="ms.date" content="2025-06-06T00:00:00Z" />
	
		<meta name="ms.service" content="sql" />
	
		<meta name="ms.topic" content="concept-article" />
	
		<meta name="ms.custom" content="ignite-2025" />
	
		<meta name="ai-usage" content="ai-assisted" />
	
		<meta name="document_id" content="45a7c96a-9d41-83e8-0ae8-b73fff390f48" />
	
		<meta name="document_version_independent_id" content="1a880308-6a3b-6944-6428-1331801b327a" />
	
		<meta name="updated_at" content="2025-12-10T18:36:00Z" />
	
		<meta name="original_content_git_url" content="https://github.com/MicrosoftDocs/sql-docs-pr/blob/live/docs/relational-databases/query-processing-architecture-guide.md" />
	
		<meta name="gitcommit" content="https://github.com/MicrosoftDocs/sql-docs-pr/blob/cfa2ba8dab72b92ace1684e0f4e9b4cf09d417f7/docs/relational-databases/query-processing-architecture-guide.md" />
	
		<meta name="git_commit_id" content="cfa2ba8dab72b92ace1684e0f4e9b4cf09d417f7" />
	
		<meta name="monikers" content="azuresqldb-current" />
	
		<meta name="monikers" content="azuresqldb-mi-current" />
	
		<meta name="monikers" content="fabric-sqldb" />
	
		<meta name="monikers" content="sql-server-linux-2017" />
	
		<meta name="monikers" content="sql-server-linux-ver15" />
	
		<meta name="monikers" content="sql-server-linux-ver16" />
	
		<meta name="monikers" content="sql-server-linux-ver17" />
	
		<meta name="monikers" content="sql-server-2016" />
	
		<meta name="monikers" content="sql-server-2017" />
	
		<meta name="monikers" content="sql-server-ver15" />
	
		<meta name="monikers" content="sql-server-ver16" />
	
		<meta name="monikers" content="sql-server-ver17" />
	
		<meta name="default_moniker" content="sql-server-ver17" />
	
		<meta name="site_name" content="Docs" />
	
		<meta name="depot_name" content="SQL.sql-content" />
	
		<meta name="schema" content="Conceptual" />
	
		<meta name="toc_rel" content="../toc.json" />
	
		<meta name="pdf_url_template" content="https://learn.microsoft.com/pdfstore/en-us/SQL.sql-content/{branchName}{pdfName}" />
	
		<meta name="word_count" content="18473" />
	
		<meta name="config_moniker_range" content="=azuresqldb-current || =azuresqldb-mi-current || =azure-sqldw-latest || &gt;=aps-pdw-2016 || &gt;=sql-server-2016 || &gt;=sql-server-linux-2017 || =fabric || =fabric-sqldb" />
	
		<meta name="asset_id" content="relational-databases/query-processing-architecture-guide" />
	
		<meta name="moniker_range_name" content="3971ca71bf673f495af6fc68328a59cc" />
	
		<meta name="item_type" content="Content" />
	
		<meta name="source_path" content="docs/relational-databases/query-processing-architecture-guide.md" />
	
		<meta name="previous_tlsh_hash" content="2AC8AEB3662C8611FF831EC2259B9B9121F1C148B5B07ED814293662B50A3EB39F5C58F6AB6373842332065713D2E1AD91D6A73BD0BC736156B5B86DC22C3142E7DA3BFBE5" />
	
		<meta name="github_feedback_content_git_url" content="https://github.com/MicrosoftDocs/sql-docs/blob/live/docs/relational-databases/query-processing-architecture-guide.md" />
	
		<meta name="markdown_url" content="https://learn.microsoft.com/en-us/sql/relational-databases/query-processing-architecture-guide?view=sql-server-ver17&amp;accept=text/markdown" />
	 
		<meta name="cmProducts" content="https://authoring-docs-microsoft.poolparty.biz/devrel/cbe4ca68-43ac-4375-aba5-5945a6394c20" data-source="generated" />
	
		<meta name="cmProducts" content="https://authoring-docs-microsoft.poolparty.biz/devrel/8b896464-3b7d-4e1f-84b0-9bb45aeb5f64" data-source="generated" />
	
		<meta name="cmProducts" content="https://authoring-docs-microsoft.poolparty.biz/devrel/86a4b315-a9f1-4577-b985-6fb0e0e67420" data-source="generated" />
	
		<meta name="spProducts" content="https://authoring-docs-microsoft.poolparty.biz/devrel/ced846cc-6a3c-4c8f-9dfb-3de0e90e2742" data-source="generated" />
	
		<meta name="spProducts" content="https://authoring-docs-microsoft.poolparty.biz/devrel/b1d2d671-9549-46e8-918c-24349120dbf5" data-source="generated" />
	
		<meta name="spProducts" content="https://authoring-docs-microsoft.poolparty.biz/devrel/96ac410d-d052-4707-8007-df31dd0fe041" data-source="generated" />
	

			<!-- assets and js globals -->
			
			<link rel="stylesheet" href="/static/assets/0.4.03336.7510-899cc417/styles/site-ltr.css" />
			
			<link rel="preconnect" href="//mscom.demdex.net" crossorigin />
						<link rel="dns-prefetch" href="//target.microsoft.com" />
						<link rel="dns-prefetch" href="//microsoftmscompoc.tt.omtrdc.net" />
						<link
							rel="preload"
							as="script"
							href="/static/third-party/adobe-target/at-js/2.9.0/at.js"
							integrity="sha384-l4AKhsU8cUWSht4SaJU5JWcHEWh1m4UTqL08s6b/hqBLAeIDxTNl+AMSxTLx6YMI"
							crossorigin="anonymous"
							id="adobe-target-script"
							type="application/javascript"
						/>
			<script src="https://wcpstatic.microsoft.com/mscc/lib/v2/wcp-consent.js"></script>
			<script src="https://js.monitor.azure.com/scripts/c/ms.jsll-4.min.js"></script>
			<script src="/_themes/docs.theme/master/en-us/_themes/global/deprecation.js"></script>

			<!-- msdocs global object -->
			<script id="msdocs-script">
		var msDocs = {
  "environment": {
    "accessLevel": "online",
    "azurePortalHostname": "portal.azure.com",
    "reviewFeatures": false,
    "supportLevel": "production",
    "systemContent": true,
    "siteName": "learn",
    "legacyHosting": false
  },
  "data": {
    "contentLocale": "en-us",
    "contentDir": "ltr",
    "userLocale": "en-us",
    "userDir": "ltr",
    "pageTemplate": "Conceptual",
    "brand": "",
    "context": {},
    "standardFeedback": true,
    "showFeedbackReport": false,
    "feedbackHelpLinkType": "get-help-at-qna",
    "feedbackHelpLinkUrl": "https://learn.microsoft.com/answers/tags/191/sql-server",
    "feedbackSystem": "Standard",
    "feedbackGitHubRepo": "MicrosoftDocs/sql-docs",
    "feedbackProductUrl": "https://feedback.azure.com/d365community/forum/04fe6ee0-3b25-ec11-b6e6-000d3a4f0da0",
    "extendBreadcrumb": false,
    "isEditDisplayable": true,
    "isPrivateUnauthorized": false,
    "hideViewSource": false,
    "isPermissioned": false,
    "hasRecommendations": true,
    "contributors": [
      {
        "name": "MikeRayMSFT",
        "url": "https://github.com/MikeRayMSFT"
      },
      {
        "name": "rwestMSFT",
        "url": "https://github.com/rwestMSFT"
      },
      {
        "name": "rmca14",
        "url": "https://github.com/rmca14"
      },
      {
        "name": "PiJoCoder",
        "url": "https://github.com/PiJoCoder"
      },
      {
        "name": "Saisang",
        "url": "https://github.com/Saisang"
      },
      {
        "name": "WilliamDAssafMSFT",
        "url": "https://github.com/WilliamDAssafMSFT"
      },
      {
        "name": "erikdarlingdata",
        "url": "https://github.com/erikdarlingdata"
      },
      {
        "name": "pelinat",
        "url": "https://github.com/pelinat"
      },
      {
        "name": "rothja",
        "url": "https://github.com/rothja"
      },
      {
        "name": "0x7FFFFFFFFFFFFFFF",
        "url": "https://github.com/0x7FFFFFFFFFFFFFFF"
      },
      {
        "name": "alexbuckgit",
        "url": "https://github.com/alexbuckgit"
      },
      {
        "name": "markingmyname",
        "url": "https://github.com/markingmyname"
      },
      {
        "name": "pmasl",
        "url": "https://github.com/pmasl"
      },
      {
        "name": "WilliamAntonRohm",
        "url": "https://github.com/WilliamAntonRohm"
      },
      {
        "name": "julieMSFT",
        "url": "https://github.com/julieMSFT"
      },
      {
        "name": "DCtheGeek",
        "url": "https://github.com/DCtheGeek"
      },
      {
        "name": "ktoliver",
        "url": "https://github.com/ktoliver"
      },
      {
        "name": "atikmapari",
        "url": "https://github.com/atikmapari"
      },
      {
        "name": "JKirsch1",
        "url": "https://github.com/JKirsch1"
      },
      {
        "name": "PhilB-MSFT",
        "url": "https://github.com/PhilB-MSFT"
      },
      {
        "name": "MrJoeSack",
        "url": "https://github.com/MrJoeSack"
      },
      {
        "name": "john-par",
        "url": "https://github.com/john-par"
      },
      {
        "name": "CarlRabeler",
        "url": "https://github.com/CarlRabeler"
      },
      {
        "name": "craigg-msft",
        "url": "https://github.com/craigg-msft"
      },
      {
        "name": "nschonni",
        "url": "https://github.com/nschonni"
      },
      {
        "name": "v-alje",
        "url": "https://github.com/v-alje"
      },
      {
        "name": "BYHAM",
        "url": "https://github.com/BYHAM"
      }
    ]
  },
  "functions": {}
};;
	</script>

			<!-- base scripts, msdocs global should be before this -->
			<script src="/static/assets/0.4.03336.7510-899cc417/scripts/en-us/index-docs.js"></script>
			

			<!-- json-ld -->
			
		</head>
	
			<body
				id="body"
				data-bi-name="body"
				class="layout-body "
				lang="en-us"
				dir="ltr"
			>
				<header class="layout-body-header">
		<div class="header-holder has-default-focus">
			
		<a
			href="#main"
			
			style="z-index: 1070"
			class="outline-color-text visually-hidden-until-focused position-fixed inner-focus focus-visible top-0 left-0 right-0 padding-xs text-align-center background-color-body"
			
		>
			Skip to main content
		</a>
	
		<a
			href="#"
			data-skip-to-ask-learn
			style="z-index: 1070"
			class="outline-color-text visually-hidden-until-focused position-fixed inner-focus focus-visible top-0 left-0 right-0 padding-xs text-align-center background-color-body"
			hidden
		>
			Skip to Ask Learn chat experience
		</a>
	

			<div hidden id="cookie-consent-holder" data-test-id="cookie-consent-container"></div>
			<!-- Unsupported browser warning -->
			<div
				id="unsupported-browser"
				style="background-color: white; color: black; padding: 16px; border-bottom: 1px solid grey;"
				hidden
			>
				<div style="max-width: 800px; margin: 0 auto;">
					<p style="font-size: 24px">This browser is no longer supported.</p>
					<p style="font-size: 16px; margin-top: 16px;">
						Upgrade to Microsoft Edge to take advantage of the latest features, security updates, and technical support.
					</p>
					<div style="margin-top: 12px;">
						<a
							href="https://go.microsoft.com/fwlink/p/?LinkID=2092881 "
							style="background-color: #0078d4; border: 1px solid #0078d4; color: white; padding: 6px 12px; border-radius: 2px; display: inline-block;"
						>
							Download Microsoft Edge
						</a>
						<a
							href="https://learn.microsoft.com/en-us/lifecycle/faq/internet-explorer-microsoft-edge"
							style="background-color: white; padding: 6px 12px; border: 1px solid #505050; color: #171717; border-radius: 2px; display: inline-block;"
						>
							More info about Internet Explorer and Microsoft Edge
						</a>
					</div>
				</div>
			</div>
			<!-- site header -->
			<header
				id="ms--site-header"
				data-test-id="site-header-wrapper"
				role="banner"
				itemscope="itemscope"
				itemtype="http://schema.org/Organization"
			>
				<div
					id="ms--mobile-nav"
					class="site-header display-none-tablet padding-inline-none gap-none"
					data-bi-name="mobile-header"
					data-test-id="mobile-header"
				></div>
				<div
					id="ms--primary-nav"
					class="site-header display-none display-flex-tablet"
					data-bi-name="L1-header"
					data-test-id="primary-header"
				></div>
				<div
					id="ms--secondary-nav"
					class="site-header display-none display-flex-tablet"
					data-bi-name="L2-header"
					data-test-id="secondary-header"
					
				></div>
			</header>
			
		<!-- banner -->
		<div data-banner>
			<div id="disclaimer-holder"></div>
			
		</div>
		<!-- banner end -->
	
		</div>
	</header>
				 <section
					id="layout-body-menu"
					class="layout-body-menu display-flex"
					data-bi-name="menu"
			  >
					
		<div
			id="left-container"
			class="left-container display-none display-block-tablet padding-inline-sm padding-bottom-sm width-full"
			data-toc-container="true"
		>
			<!-- Regular TOC content (default) -->
			<div id="ms--toc-content" class="height-full">
				<nav
					id="affixed-left-container"
					class="margin-top-sm-tablet position-sticky display-flex flex-direction-column"
					aria-label="Primary"
					data-bi-name="left-toc"
					role="navigation"
				></nav>
			</div>
			<!-- Collapsible TOC content (hidden by default) -->
			<div id="ms--toc-content-collapsible" class="height-full" hidden>
				<nav
					id="affixed-left-container"
					class="margin-top-sm-tablet position-sticky display-flex flex-direction-column"
					aria-label="Primary"
					data-bi-name="left-toc"
					role="navigation"
				>
					<div
						id="ms--collapsible-toc-header"
						class="display-flex flex-direction-row-reverse justify-content-space-between align-items-center margin-bottom-xxs"
					>
						<button
							type="button"
							class="button button-clear inner-focus"
							data-collapsible-toc-toggle
							aria-expanded="true"
							aria-controls="ms--collapsible-toc-content"
							aria-label="Table of contents"
						>
							<span class="icon font-size-h4" aria-hidden="true">
								<span class="docon docon-panel-left-contract"></span>
							</span>
						</button>
						<div id="ms--collapsible-toc-moniker-slot" class="flex-grow-1"></div>
					</div>
				</nav>
			</div>
		</div>
	
			  </section>

				<main
					id="main"
					role="main"
					class="layout-body-main "
					data-bi-name="content"
					lang="en-us"
					dir="ltr"
				>
					
			<div
		id="ms--content-header"
		class="content-header default-focus border-bottom-none"
		data-bi-name="content-header"
	>
		<div class="content-header-controls margin-xxs margin-inline-sm-tablet">
			<button
				type="button"
				class="contents-button button button-sm margin-right-xxs"
				data-bi-name="contents-expand"
				aria-haspopup="true"
				data-contents-button
			>
				<span class="icon" aria-hidden="true"><span class="docon docon-menu"></span></span>
				<span class="contents-expand-title"> Table of contents </span>
			</button>
			<button
				type="button"
				class="ap-collapse-behavior ap-expanded button button-sm"
				data-bi-name="ap-collapse"
				aria-controls="action-panel"
			>
				<span class="icon" aria-hidden="true"><span class="docon docon-exit-mode"></span></span>
				<span>Exit editor mode</span>
			</button>
		</div>
	</div>
			<div data-main-column class="padding-sm padding-top-none padding-top-sm-tablet">
				<div>
					
		<div id="article-header" class="background-color-body margin-bottom-xs display-none-print">
			<div class="display-flex align-items-center justify-content-space-between">
				
		<details
			id="article-header-breadcrumbs-overflow-popover"
			class="popover"
			data-for="article-header-breadcrumbs"
		>
			<summary
				class="button button-clear button-primary button-sm inner-focus"
				aria-label="All breadcrumbs"
			>
				<span class="icon">
					<span class="docon docon-more"></span>
				</span>
			</summary>
			<div id="article-header-breadcrumbs-overflow" class="popover-content padding-none"></div>
		</details>

		<bread-crumbs
			id="article-header-breadcrumbs"
			role="group"
			aria-label="Breadcrumbs"
			data-test-id="article-header-breadcrumbs"
			class="overflow-hidden flex-grow-1 margin-right-sm margin-right-md-tablet margin-right-lg-desktop margin-left-negative-xxs padding-left-xxs"
		></bread-crumbs>
	 
		<div
			id="article-header-page-actions"
			class="opacity-none margin-left-auto display-flex flex-wrap-no-wrap align-items-stretch"
		>
			
		<button
			class="button button-sm border-none inner-focus display-none-tablet flex-shrink-0 "
			data-bi-name="ask-learn-assistant-entry"
			data-test-id="ask-learn-assistant-modal-entry-mobile"
			data-ask-learn-modal-entry
			
			type="button"
			style="min-width: max-content;"
			aria-expanded="false"
			aria-label="Ask Learn"
			hidden
		>
			<span class="icon font-size-lg" aria-hidden="true">
				<span class="docon docon-chat-sparkle-fill gradient-ask-learn-logo"></span>
			</span>
		</button>
		<button
			class="button button-sm display-none display-inline-flex-tablet display-none-desktop flex-shrink-0 margin-right-xxs border-color-ask-learn "
			data-bi-name="ask-learn-assistant-entry"
			
			data-test-id="ask-learn-assistant-modal-entry-tablet"
			data-ask-learn-modal-entry
			type="button"
			style="min-width: max-content;"
			aria-expanded="false"
			hidden
		>
			<span class="icon font-size-lg" aria-hidden="true">
				<span class="docon docon-chat-sparkle-fill gradient-ask-learn-logo"></span>
			</span>
			<span>Ask Learn</span>
		</button>
		<button
			class="button button-sm display-none flex-shrink-0 display-inline-flex-desktop margin-right-xxs border-color-ask-learn "
			data-bi-name="ask-learn-assistant-entry"
			
			data-test-id="ask-learn-assistant-flyout-entry"
			data-ask-learn-flyout-entry
			data-flyout-button="toggle"
			type="button"
			style="min-width: max-content;"
			aria-expanded="false"
			aria-controls="ask-learn-flyout"
			hidden
		>
			<span class="icon font-size-lg" aria-hidden="true">
				<span class="docon docon-chat-sparkle-fill gradient-ask-learn-logo"></span>
			</span>
			<span>Ask Learn</span>
		</button>
	 
		<button
			type="button"
			id="ms--focus-mode-button"
			data-focus-mode
			data-bi-name="focus-mode-entry"
			class="button button-sm flex-shrink-0 margin-right-xxs display-none display-inline-flex-desktop"
		>
			<span class="icon font-size-lg" aria-hidden="true">
				<span class="docon docon-glasses"></span>
			</span>
			<span>Focus mode</span>
		</button>
	 

			<details class="popover popover-right" id="article-header-page-actions-overflow">
				<summary
					class="justify-content-flex-start button button-clear button-sm button-primary inner-focus"
					aria-label="More actions"
					title="More actions"
				>
					<span class="icon" aria-hidden="true">
						<span class="docon docon-more-vertical"></span>
					</span>
				</summary>
				<div class="popover-content">
					
		<button
			data-page-action-item="overflow-mobile"
			type="button"
			class="button-block button-sm inner-focus button button-clear display-none-tablet justify-content-flex-start text-align-left"
			data-bi-name="contents-expand"
			data-contents-button
			data-popover-close
		>
			<span class="icon">
				<span class="docon docon-editor-list-bullet" aria-hidden="true"></span>
			</span>
			<span class="contents-expand-title">Table of contents</span>
		</button>
	 
		<a
			id="lang-link-overflow"
			class="button-sm inner-focus button button-clear button-block justify-content-flex-start text-align-left"
			data-bi-name="language-toggle"
			data-page-action-item="overflow-all"
			data-check-hidden="true"
			data-read-in-link
			href="#"
			hidden
		>
			<span class="icon" aria-hidden="true" data-read-in-link-icon>
				<span class="docon docon-locale-globe"></span>
			</span>
			<span data-read-in-link-text>Read in English</span>
		</a>
	 
		<button
			type="button"
			class="collection button button-clear button-sm button-block justify-content-flex-start text-align-left inner-focus"
			data-list-type="collection"
			data-bi-name="collection"
			data-page-action-item="overflow-all"
			data-check-hidden="true"
			data-popover-close
		>
			<span class="icon" aria-hidden="true">
				<span class="docon docon-circle-addition"></span>
			</span>
			<span class="collection-status">Add</span>
		</button>
	
					
		<button
			type="button"
			class="collection button button-block button-clear button-sm justify-content-flex-start text-align-left inner-focus"
			data-list-type="plan"
			data-bi-name="plan"
			data-page-action-item="overflow-all"
			data-check-hidden="true"
			data-popover-close
			hidden
		>
			<span class="icon" aria-hidden="true">
				<span class="docon docon-circle-addition"></span>
			</span>
			<span class="plan-status">Add to plan</span>
		</button>
	  
		<a
			data-contenteditbtn
			class="button button-clear button-block button-sm inner-focus justify-content-flex-start text-align-left text-decoration-none"
			data-bi-name="edit"
			
			href="https://github.com/MicrosoftDocs/sql-docs/blob/live/docs/relational-databases/query-processing-architecture-guide.md"
			data-original_content_git_url="https://github.com/MicrosoftDocs/sql-docs-pr/blob/live/docs/relational-databases/query-processing-architecture-guide.md"
			data-original_content_git_url_template="{repo}/blob/{branch}/docs/relational-databases/query-processing-architecture-guide.md"
			data-pr_repo=""
			data-pr_branch=""
		>
			<span class="icon" aria-hidden="true">
				<span class="docon docon-edit-outline"></span>
			</span>
			<span>Edit</span>
		</a>
	
					
		<hr class="margin-block-xxs" />
		<h4 class="font-size-sm padding-left-xxs">Share via</h4>
		
					<a
						class="button button-clear button-sm inner-focus button-block justify-content-flex-start text-align-left text-decoration-none share-facebook"
						data-bi-name="facebook"
						data-page-action-item="overflow-all"
						href="#"
					>
						<span class="icon color-primary" aria-hidden="true">
							<span class="docon docon-facebook-share"></span>
						</span>
						<span>Facebook</span>
					</a>

					<a
						href="#"
						class="button button-clear button-sm inner-focus button-block justify-content-flex-start text-align-left text-decoration-none share-twitter"
						data-bi-name="twitter"
						data-page-action-item="overflow-all"
					>
						<span class="icon color-text" aria-hidden="true">
							<span class="docon docon-xlogo-share"></span>
						</span>
						<span>x.com</span>
					</a>

					<a
						href="#"
						class="button button-clear button-sm inner-focus button-block justify-content-flex-start text-align-left text-decoration-none share-linkedin"
						data-bi-name="linkedin"
						data-page-action-item="overflow-all"
					>
						<span class="icon color-primary" aria-hidden="true">
							<span class="docon docon-linked-in-logo"></span>
						</span>
						<span>LinkedIn</span>
					</a>
					<a
						href="#"
						class="button button-clear button-sm inner-focus button-block justify-content-flex-start text-align-left text-decoration-none share-email"
						data-bi-name="email"
						data-page-action-item="overflow-all"
					>
						<span class="icon color-primary" aria-hidden="true">
							<span class="docon docon-mail-message"></span>
						</span>
						<span>Email</span>
					</a>
			  
	 
		<hr class="margin-block-xxs" />
		
				<button
					class="button button-block button-clear button-sm justify-content-flex-start text-align-left inner-focus"
					type="button"
					data-bi-name="copy-markdown"
					data-page-action-item="overflow-all"
					data-copy-markdown
					data-copy-state="idle"
					data-check-hidden="true"
				>
					<span class="icon color-primary" aria-hidden="true">
						<span data-show-when="idle" class="docon docon-code-lang"></span>
						<span data-show-when="loading" class="loader" hidden></span>
						<span data-show-when="success" class="docon docon-check-mark" hidden></span>
					</span>
					<span>Copy Markdown</span>
				</button>
		   
				<button
					class="button button-block button-clear button-sm justify-content-flex-start text-align-left inner-focus"
					type="button"
					data-bi-name="print"
					data-page-action-item="overflow-all"
					data-popover-close
					data-print-page
					data-check-hidden="true"
				>
					<span class="icon color-primary" aria-hidden="true">
						<span class="docon docon-print"></span>
					</span>
					<span>Print</span>
				</button>
		  
	
				</div>
			</details>
		</div>
	
			</div>
		</div>
	  
		<!-- privateUnauthorizedTemplate is hidden by default -->
		<div unauthorized-private-section data-bi-name="permission-content-unauthorized-private" hidden>
			<hr class="hr margin-top-xs margin-bottom-sm" />
			<div class="notification notification-info">
				<div class="notification-content">
					<p class="margin-top-none notification-title">
						<span class="icon">
							<span class="docon docon-exclamation-circle-solid" aria-hidden="true"></span>
						</span>
						<span>Note</span>
					</p>
					<p class="margin-top-none authentication-determined not-authenticated">
						Access to this page requires authorization. You can try <a class="docs-sign-in" href="#" data-bi-name="permission-content-sign-in">signing in</a> or <a  class="docs-change-directory" data-bi-name="permisson-content-change-directory">changing directories</a>.
					</p>
					<p class="margin-top-none authentication-determined authenticated">
						Access to this page requires authorization. You can try <a class="docs-change-directory" data-bi-name="permisson-content-change-directory">changing directories</a>.
					</p>
				</div>
			</div>
		</div>
	
					<div class="content"><h1 id="query-processing-architecture-guide">Query processing architecture guide</h1></div>
					
		<div
			id="article-metadata"
			data-bi-name="article-metadata"
			data-test-id="article-metadata"
			class="page-metadata-container display-flex gap-xxs justify-content-space-between align-items-center flex-wrap-wrap"
		>
			 
				<div
					id="user-feedback"
					class="margin-block-xxs display-none display-none-print"
					hidden
					data-hide-on-archived
				>
					
		<button
			id="user-feedback-button"
			data-test-id="conceptual-feedback-button"
			class="button button-sm button-clear button-primary display-none"
			type="button"
			data-bi-name="user-feedback-button"
			data-user-feedback-button
			hidden
		>
			<span class="icon" aria-hidden="true">
				<span class="docon docon-like"></span>
			</span>
			<span>Feedback</span>
		</button>
	
				</div>
		  
		</div>
	 
		<div data-id="ai-summary" hidden>
			<div id="ms--ai-summary-cta" class="margin-top-xs display-flex align-items-center">
				<span class="icon" aria-hidden="true">
					<span class="docon docon-sparkle-fill gradient-text-vivid"></span>
				</span>
				<button
					id="ms--ai-summary"
					type="button"
					class="tag tag-sm tag-suggestion margin-left-xxs"
					data-test-id="ai-summary-cta"
					data-bi-name="ai-summary-cta"
					data-an="ai-summary"
				>
					<span class="ai-summary-cta-text">
						Summarize this article for me
					</span>
				</button>
			</div>
			<!-- Slot where the client will render the summary card after the user clicks the CTA -->
			<div id="ms--ai-summary-header" class="margin-top-xs"></div>
		</div>
	 
		<nav
			id="center-doc-outline"
			class="doc-outline is-hidden-desktop display-none-print margin-bottom-sm"
			data-bi-name="intopic toc"
			aria-label="In this article"
		>
			<h2 id="ms--in-this-article" class="title is-6 margin-block-xs">
				In this article
			</h2>
		</nav>
	
					<div class="content"><p><strong>Applies to:</strong> <img src="../includes/media/yes-icon.svg?view=sql-server-ver17" role="presentation" data-linktype="relative-path">
 <a href="../sql-server/sql-docs-navigation-guide?view=sql-server-ver17#applies-to" data-linktype="relative-path">SQL Server</a> <img src="../includes/media/yes-icon.svg?view=sql-server-ver17" role="presentation" data-linktype="relative-path">
 <a href="../sql-server/sql-docs-navigation-guide?view=sql-server-ver17#applies-to" data-linktype="relative-path">Azure SQL Database</a> <img src="../includes/media/yes-icon.svg?view=sql-server-ver17" role="presentation" data-linktype="relative-path">
 <a href="../sql-server/sql-docs-navigation-guide?view=sql-server-ver17#applies-to" data-linktype="relative-path">Azure SQL Managed Instance</a> <img src="../includes/media/yes-icon.svg?view=sql-server-ver17" role="presentation" data-linktype="relative-path">
 <a href="../sql-server/sql-docs-navigation-guide?view=sql-server-ver17#applies-to" data-linktype="relative-path">SQL database in Microsoft Fabric</a></p>
<p>The SQL Server Database Engine processes queries on various data storage architectures such as local tables, partitioned tables, and tables distributed across multiple servers. The following sections cover how SQL Server processes queries and optimizes query reuse through execution plan caching.</p>
<h2 id="execution-modes">Execution modes</h2>
<p>The SQL Server Database Engine can process Transact-SQL statements using two distinct processing modes:</p>
<ul>
<li>Row mode execution</li>
<li>Batch mode execution</li>
</ul>
<h3 id="row-mode-execution">Row mode execution</h3>
<p><em>Row mode execution</em> is a query processing method used with traditional RDBMS tables, where data is stored in row format. When a query is executed and accesses data in row store tables, the execution tree operators and child operators read each required row, across all the columns specified in the table schema. From each row that is read, SQL Server then retrieves the columns that are required for the result set, as referenced by a SELECT statement, JOIN predicate, or filter predicate.</p>
<div class="NOTE">
<p>Note</p>
<p>Row mode execution is very efficient for OLTP scenarios, but can be less efficient when scanning large amounts of data, for example in Data Warehousing scenarios.</p>
</div>
<h3 id="batch-mode-execution">Batch mode execution</h3>
<p><em>Batch mode execution</em> is a query processing method used to process multiple rows together (hence the term batch). Each column within a batch is stored as a vector in a separate area of memory, so batch mode processing is vector-based. Batch mode processing also uses algorithms that are optimized for the multi-core CPUs and increased memory throughput that are found on modern hardware.</p>
<p>When it was first introduced, batch mode execution was closely integrated with, and optimized around, the columnstore storage format. However, starting with SQL Server 2019 (15.x) and in Azure SQL Database, batch mode execution no longer requires columnstore indexes. For more information, see <a href="performance/intelligent-query-processing-details?view=sql-server-ver17#batch-mode-on-rowstore" data-linktype="relative-path">Batch mode on rowstore</a>.</p>
<p>Batch mode processing operates on compressed data when possible, and eliminates the <a href="showplan-logical-and-physical-operators-reference?view=sql-server-ver17#exchange" data-linktype="relative-path">exchange operator</a> used by row mode execution. The result is better parallelism and faster performance.</p>
<p>When a query is executed in batch mode, and accesses data in columnstore indexes, the execution tree operators and child operators read multiple rows together in column segments. SQL Server reads only the columns required for the result, as referenced by a SELECT statement, JOIN predicate, or filter predicate. For more information on columnstore indexes, see <a href="sql-server-index-design-guide?view=sql-server-ver17#columnstore_index" data-linktype="relative-path">Columnstore Index Architecture</a>.</p>
<div class="NOTE">
<p>Note</p>
<p>Batch mode execution is very efficient Data Warehousing scenarios, where large amounts of data are read and aggregated.</p>
</div>
<h2 id="sql-statement-processing">SQL statement processing</h2>
<p>Processing a single Transact-SQL statement is the most basic way that SQL Server executes Transact-SQL statements. The steps used to process a single <code>SELECT</code> statement that references only local base tables (no views or remote tables) illustrates the basic process.</p>
<h3 id="logical-operator-precedence">Logical operator precedence</h3>
<p>When more than one logical operator is used in a statement, <code>NOT</code> is evaluated first, then <code>AND</code>, and finally <code>OR</code>. Arithmetic, and bitwise, operators are handled before logical operators. For more information, see <a href="../t-sql/language-elements/operator-precedence-transact-sql?view=sql-server-ver17" data-linktype="relative-path">Operator Precedence</a>.</p>
<p>In the following example, the color condition pertains to product model 21, and not to product model 20, because <code>AND</code> has precedence over <code>OR</code>.</p>
<pre><code class="lang-sql">SELECT ProductID, ProductModelID
FROM Production.Product
WHERE ProductModelID = 20 OR ProductModelID = 21
  AND Color = 'Red';
GO
</code></pre>
<p>You can change the meaning of the query by adding parentheses to force evaluation of the <code>OR</code> first. The following query finds only products under models 20 and 21 that are red.</p>
<pre><code class="lang-sql">SELECT ProductID, ProductModelID
FROM Production.Product
WHERE (ProductModelID = 20 OR ProductModelID = 21)
  AND Color = 'Red';
GO
</code></pre>
<p>Using parentheses, even when they aren't required, can improve the readability of queries, and reduce the chance of making a subtle mistake because of operator precedence. There is no significant performance penalty in using parentheses. The following example is more readable than the original example, although they are syntactically the same.</p>
<pre><code class="lang-sql">SELECT ProductID, ProductModelID
FROM Production.Product
WHERE ProductModelID = 20 OR (ProductModelID = 21
  AND Color = 'Red');
GO
</code></pre>
<h3 id="optimizing-select-statements"> Optimize SELECT statements</h3>
<p>A <code>SELECT</code> statement is non-procedural; it doesn't state the exact steps that the database server should use to retrieve the requested data. This means that the database server must analyze the statement to determine the most efficient way to extract the requested data. This is referred to as optimizing the <code>SELECT</code> statement. The component that does this, is called the Query Optimizer. The input to the Query Optimizer consists of the query, the database schema (table and index definitions), and the database statistics. The output of the Query Optimizer is a query execution plan, sometimes referred to as a query plan, or execution plan. The contents of an execution plan are described in more detail later in this article.</p>
<p>The inputs and outputs of the Query Optimizer during optimization of a single <code>SELECT</code> statement are illustrated in the following diagram:</p>
<p><span class="mx-imgBorder">
<img src="media/query-processing-architecture-guide/query-processor-io.gif?view=sql-server-ver17" alt="Diagram of the Query processor I/O." data-linktype="relative-path">
</span>
</p>
<p>A <code>SELECT</code> statement defines only the following:</p>
<ul>
<li>The format of the result set. This is specified mostly in the select list. However, other clauses such as <code>ORDER BY</code> and <code>GROUP BY</code> also affect the final form of the result set.</li>
<li>The tables that contain the source data. This is specified in the <code>FROM</code> clause.</li>
<li>How the tables are logically related for the purposes of the <code>SELECT</code> statement. This is defined in the join specifications, which might appear in the <code>WHERE</code> clause or in an <code>ON</code> clause following <code>FROM</code>.</li>
<li>The conditions that the rows in the source tables must satisfy to qualify for the <code>SELECT</code> statement. These are specified in the <code>WHERE</code> and <code>HAVING</code> clauses.</li>
</ul>
<p>A query execution plan is a definition of the following:</p>
<ul>
<li><p><strong>The sequence in which the source tables are accessed.</strong><br>
Typically, there are many sequences in which the database server can access the base tables to build the result set. For example, if the <code>SELECT</code> statement references three tables, the database server could first access <code>TableA</code>, use the data from <code>TableA</code> to extract matching rows from <code>TableB</code>, and then use the data from <code>TableB</code> to extract data from <code>TableC</code>. The other sequences in which the database server could access the tables are:<br>
<code>TableC</code>, <code>TableB</code>, <code>TableA</code>, or<br>
<code>TableB</code>, <code>TableA</code>, <code>TableC</code>, or<br>
<code>TableB</code>, <code>TableC</code>, <code>TableA</code>, or<br>
<code>TableC</code>, <code>TableA</code>, <code>TableB</code></p>
</li>
<li><p><strong>The methods used to extract data from each table.</strong><br>
Generally, there are different methods for accessing the data in each table. If only a few rows with specific key values are required, the database server can use an index. If all the rows in the table are required, the database server can ignore the indexes and perform a table scan. If all the rows in a table are required but there is an index whose key columns are in an <code>ORDER BY</code>, performing an index scan instead of a table scan might save a separate sort of the result set. If a table is very small, table scans might be the most efficient method for almost all access to the table.</p>
</li>
<li><p><strong>The methods used to compute calculations, and how to filter, aggregate, and sort data from each table.</strong><br>
As data is accessed from tables, there are different methods to perform calculations over data such as computing scalar values, and to aggregate and sort data as defined in the query text, for example when using a <code>GROUP BY</code> or <code>ORDER BY</code> clause, and how to filter data, for example when using a <code>WHERE</code> or <code>HAVING</code> clause.</p>
</li>
</ul>
<p>The process of selecting one execution plan from potentially many possible plans is referred to as optimization. The Query Optimizer is one of the most important components of the Database Engine. While some overhead is used by the Query Optimizer to analyze the query and select a plan, this overhead is typically saved several-fold when the Query Optimizer picks an efficient execution plan. For example, two construction companies can be given identical blueprints for a house. If one company spends a few days at the beginning to plan how they will build the house, and the other company begins building without planning, the company that takes the time to plan their project will probably finish first.</p>
<p>The SQL Server Query Optimizer is a cost-based optimizer. Each possible execution plan has an associated cost in terms of the amount of computing resources used. The Query Optimizer must analyze the possible plans and choose the one with the lowest estimated cost. Some complex <code>SELECT</code> statements have thousands of possible execution plans. In these cases, the Query Optimizer doesn't analyze all possible combinations. Instead, it uses complex algorithms to find an execution plan that has a cost reasonably close to the minimum possible cost.</p>
<p>The SQL Server Query Optimizer doesn't choose only the execution plan with the lowest resource cost; it chooses the plan that returns results to the user with a reasonable cost in resources and that returns the results the fastest. For example, processing a query in parallel typically uses more resources than processing it serially, but completes the query faster. The SQL Server Query Optimizer will use a parallel execution plan to return results if the load on the server won't be adversely affected.</p>
<p>The SQL Server Query Optimizer relies on distribution statistics when it estimates the resource costs of different methods for extracting information from a table or index. Distribution statistics are kept for columns and indexes, and hold information on the density<sup>1</sup> of the underlying data. This is used to indicate the selectivity of the values in a particular index or column. For example, in a table representing cars, many cars have the same manufacturer, but each car has a unique vehicle identification number (VIN). An index on the VIN is more selective than an index on the manufacturer, because VIN has lower density than manufacturer. If the index statistics aren't current, the Query Optimizer might not make the best choice for the current state of the table. For more information about densities, see <a href="statistics/statistics?view=sql-server-ver17#density" data-linktype="relative-path">Statistics</a>.</p>
<p><sup>1</sup> Density defines the distribution of unique values that exist in the data, or the average number of duplicate values for a given column. As density decreases, selectivity of a value increases.</p>
<p>The SQL Server Query Optimizer is important because it enables the database server to adjust dynamically to changing conditions in the database without requiring input from a programmer or database administrator. This enables programmers to focus on describing the final result of the query. They can trust that the SQL Server Query Optimizer will build an efficient execution plan for the state of the database every time the statement is run.</p>
<div class="NOTE">
<p>Note</p>
<p>SQL Server Management Studio has three options to display execution plans:</p>
<ul>
<li>The <em><strong><a href="performance/display-the-estimated-execution-plan?view=sql-server-ver17" data-linktype="relative-path">Estimated Execution Plan</a></strong></em>, which is the compiled plan, as produced by the Query Optimizer.</li>
<li>The <em><strong><a href="performance/display-an-actual-execution-plan?view=sql-server-ver17" data-linktype="relative-path">Actual Execution Plan</a></strong></em>, which is the same as the compiled plan plus its execution context. This includes runtime information available after the execution completes, such as execution warnings, or in newer versions of the Database Engine, the elapsed and CPU time used during execution.</li>
<li>The <em><strong><a href="performance/live-query-statistics?view=sql-server-ver17" data-linktype="relative-path">Live Query Statistics</a></strong></em>, which is the same as the compiled plan plus its execution context. This includes runtime information during execution progress, and is updated every second. Runtime information includes for example the actual number of rows flowing through the operators.</li>
</ul>
</div>
<h3 id="process-a-select-statement">Process a SELECT statement</h3>
<p>The basic steps that SQL Server uses to process a single SELECT statement include the following:</p>
<ol>
<li>The parser scans the <code>SELECT</code> statement and breaks it into logical units such as keywords, expressions, operators, and identifiers.</li>
<li>A query tree, sometimes referred to as a sequence tree, is built describing the logical steps needed to transform the source data into the format required by the result set.</li>
<li>The Query Optimizer analyzes different ways the source tables can be accessed. It then selects the series of steps that return the results fastest while using fewer resources. The query tree is updated to record this exact series of steps. The final, optimized version of the query tree is called the execution plan.</li>
<li>The relational engine starts executing the execution plan. As the steps that require data from the base tables are processed, the relational engine requests that the storage engine pass up data from the rowsets requested from the relational engine.</li>
<li>The relational engine processes the data returned from the storage engine into the format defined for the result set and returns the result set to the client.</li>
</ol>
<h3 id="constant-folding-and-expression-evaluation">Constant folding and expression evaluation</h3>
<p>SQL Server evaluates some constant expressions early to improve query performance. This optimization technique used by the query optimizer aims to simplify expressions at compile time rather than at runtime. It involves evaluating constant expressions during query compilation so that the resulting execution plan is more efficient. This is referred to as constant folding. A constant is a Transact-SQL literal, such as <code>3</code>, <code>'ABC'</code>, <code>'2005-12-31'</code>, <code>1.0e3</code>, or <code>0x12345678</code>. For example, take this query:</p>
<pre><code class="lang-sql">SELECT * FROM Orders WHERE OrderDate &lt; DATEADD(day, 30 * 12, '2020-01-01');
</code></pre>
<p>Here, 30 * 12 is a constant expression. SQL Server can evaluate this during compilation and rewrite the query internally as:</p>
<pre><code class="lang-sql">SELECT * FROM Orders WHERE OrderDate &lt; DATEADD(day, 360, '2020-01-01');
</code></pre>
<h4 id="foldable-expressions">Foldable expressions</h4>
<p>SQL Server uses constant folding with the following types of expressions:</p>
<ul>
<li>Arithmetic expressions, such as <code>1 + 1</code> and <code>5 / 3 * 2</code>, that contain only constants.</li>
<li>Logical expressions, such as <code>1 = 1</code> and <code>1 &gt; 2 AND 3 &gt; 4</code>, that contain only constants.</li>
<li>Built-in functions that are considered foldable by SQL Server, including <code>CAST</code> and <code>CONVERT</code>. Generally, an intrinsic function is foldable if it is a function of its inputs only and not other contextual information, such as SET options, language settings, database options, and encryption keys. Nondeterministic functions aren't foldable. Deterministic built-in functions are foldable, with some exceptions.</li>
<li>Deterministic methods of CLR user-defined types and deterministic scalar-valued CLR user-defined functions (starting with SQL Server 2012 (11.x)). For more information, see <a href="/en-us/previous-versions/sql/2014/database-engine/behavior-changes-to-database-engine-features-in-sql-server-2014#constant-folding-for-clr-user-defined-functions-and-methods" data-linktype="absolute-path">Constant Folding for CLR User-Defined Functions and Methods</a>.</li>
</ul>
<div class="NOTE">
<p>Note</p>
<p>An exception is made for large object types. If the output type of the folding process is a large object type (text,ntext, image, nvarchar(max), varchar(max), varbinary(max), or XML), then SQL Server does not fold the expression.</p>
</div>
<h4 id="nonfoldable-expressions">Nonfoldable expressions</h4>
<p>All other expression types aren't foldable. In particular, the following types of expressions aren't foldable:</p>
<ul>
<li>Nonconstant expressions such as an expression whose result depends on the value of a column.</li>
<li>Expressions whose results depend on a local variable or parameter, such as <span class="no-loc" dir="ltr" lang="en-us">@x</span>.</li>
<li>Nondeterministic functions.</li>
<li>User-defined Transact-SQL functions<sup>1</sup>.</li>
<li>Expressions whose results depend on language settings.</li>
<li>Expressions whose results depend on SET options.</li>
<li>Expressions whose results depend on server configuration options.</li>
</ul>
<p><sup>1</sup> Before SQL Server 2012 (11.x), deterministic scalar-valued CLR user-defined functions and methods of CLR user-defined types were not foldable.</p>
<h4 id="examples-of-foldable-and-nonfoldable-constant-expressions">Examples of foldable and nonfoldable constant expressions</h4>
<p>Consider the following query:</p>
<pre><code class="lang-sql">SELECT *
FROM Sales.SalesOrderHeader AS s
INNER JOIN Sales.SalesOrderDetail AS d
ON s.SalesOrderID = d.SalesOrderID
WHERE TotalDue &gt; 117.00 + 1000.00;
</code></pre>
<p>If the <code>PARAMETERIZATION</code> database option isn't set to <code>FORCED</code> for this query, then the expression <code>117.00 + 1000.00</code> is evaluated and replaced by its result, <code>1117.00</code>, before the query is compiled. Benefits of this constant folding include the following:</p>
<ul>
<li>The expression doesn't have to be evaluated repeatedly at run time.</li>
<li>The value of the expression after it is evaluated is used by the Query Optimizer to estimate the size of the result set of the portion of the query <code>TotalDue &gt; 117.00 + 1000.00</code>.</li>
</ul>
<p>On the other hand, if <code>dbo.f</code> is a scalar user-defined function, the expression <code>dbo.f(100)</code> isn't folded, because SQL Server doesn't fold expressions that involve user-defined functions, even if they are deterministic. For more information on parameterization, see <a href="#forced-parameterization" data-linktype="self-bookmark">Forced Parameterization</a> later in this article.</p>
<h4 id="expression-evaluation">Expression evaluation</h4>
<p>In addition, some expressions that aren't constant folded but whose arguments are known at compile time, whether the arguments are parameters or constants, are evaluated by the result-set size (cardinality) estimator that is part of the optimizer during optimization.</p>
<p>Specifically, the following built-in functions and special operators are evaluated at compile time if all their inputs are known: <code>UPPER</code>, <code>LOWER</code>, <code>RTRIM</code>, <code>DATEPART( YY only )</code>, <code>GETDATE</code>, <code>CAST</code>, and <code>CONVERT</code>. The following operators are also evaluated at compile time if all their inputs are known:</p>
<ul>
<li>Arithmetic operators: +, -, *, /, unary -</li>
<li>Logical Operators: <code>AND</code>, <code>OR</code>, <code>NOT</code></li>
<li>Comparison operators: &lt;, &gt;, &lt;=, &gt;=, &lt;&gt;, <code>LIKE</code>, <code>IS NULL</code>, <code>IS NOT NULL</code></li>
</ul>
<p>No other functions or operators are evaluated by the Query Optimizer during cardinality estimation.</p>
<h4 id="examples-of-compile-time-expression-evaluation">Examples of compile-time expression evaluation</h4>
<p>Consider this stored procedure:</p>
<pre><code class="lang-sql">USE AdventureWorks2022;
GO
CREATE PROCEDURE MyProc( @d datetime )
AS
SELECT COUNT(*)
FROM Sales.SalesOrderHeader
WHERE OrderDate &gt; @d+1;
</code></pre>
<p>During optimization of the <code>SELECT</code> statement in the procedure, the Query Optimizer tries to evaluate the expected cardinality of the result set for the condition <code>OrderDate &gt; @d+1</code>. The expression <code>@d+1</code> isn't constant-folded, because <code>@d</code> is a parameter. However, at optimization time, the value of the parameter is known. This allows the Query Optimizer to accurately estimate the size of the result set, which helps it select a good query plan.</p>
<p>Now consider an example similar to the previous one, except that a local variable <code>@d2</code> replaces <code>@d+1</code> in the query and the expression is evaluated in a SET statement instead of in the query.</p>
<pre><code class="lang-sql">USE AdventureWorks2022;
GO
CREATE PROCEDURE MyProc2( @d datetime )
AS
BEGIN
  DECLARE @d2 datetime
  SET @d2 = @d+1
  SELECT COUNT(*)
  FROM Sales.SalesOrderHeader
  WHERE OrderDate &gt; @d2
END;
</code></pre>
<p>When the <code>SELECT</code> statement in <code>MyProc2</code> is optimized in SQL Server, the value of <code>@d2</code> isn't known. Therefore, the Query Optimizer uses a default estimate for the selectivity of <code>OrderDate &gt; @d2</code>, (in this case 30 percent).</p>
<h3 id="process-other-statements">Process other statements</h3>
<p>The basic steps described for processing a <code>SELECT</code> statement apply to other Transact-SQL statements such as <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code>. <code>UPDATE</code> and <code>DELETE</code> statements both have to target the set of rows to be modified or deleted. The process of identifying these rows is the same process used to identify the source rows that contribute to the result set of a <code>SELECT</code> statement. The <code>UPDATE</code> and <code>INSERT</code> statements might both contain embedded <code>SELECT</code> statements that provide the data values to be updated or inserted.</p>
<p>Even Data Definition Language (DDL) statements, such as <code>CREATE PROCEDURE</code> or <code>ALTER TABLE</code>, are ultimately resolved to a series of relational operations on the system catalog tables and sometimes (such as <code>ALTER TABLE ADD COLUMN</code>) against the data tables.</p>
<h3 id="worktables">Worktables</h3>
<p>The Relational Engine might need to build a worktable to perform a logical operation specified in an Transact-SQL statement. Worktables are internal tables that are used to hold intermediate results. Worktables are generated for certain <code>GROUP BY</code>, <code>ORDER BY</code>, or <code>UNION</code> queries. For example, if an <code>ORDER BY</code> clause references columns that aren't covered by any indexes, the Relational Engine might need to generate a worktable to sort the result set into the order requested. Worktables are also sometimes used as spools that temporarily hold the result of executing a part of a query plan. Worktables are built in <code>tempdb</code> and are dropped automatically when they are no longer needed.</p>
<h3 id="view-resolution">View resolution</h3>
<p>The SQL Server query processor treats indexed and nonindexed views differently:</p>
<ul>
<li>The rows of an indexed view are stored in the database in the same format as a table. If the Query Optimizer decides to use an indexed view in a query plan, the indexed view is treated the same way as a base table.</li>
<li>Only the definition of a nonindexed view is stored, not the rows of the view. The Query Optimizer incorporates the logic from the view definition into the execution plan it builds for the Transact-SQL statement that references the nonindexed view.</li>
</ul>
<p>The logic used by the SQL Server Query Optimizer to decide when to use an indexed view is similar to the logic used to decide when to use an index on a table. If the data in the indexed view covers all or part of the Transact-SQL statement, and the Query Optimizer determines that an index on the view is the low-cost access path, the Query Optimizer will choose the index regardless of whether the view is referenced by name in the query.</p>
<p>When an Transact-SQL statement references a nonindexed view, the parser and Query Optimizer analyze the source of both the Transact-SQL statement and the view and then resolve them into a single execution plan. There isn't one plan for the Transact-SQL statement and a separate plan for the view.</p>
<p>For example, consider the following view:</p>
<pre><code class="lang-sql">USE AdventureWorks2022;
GO
CREATE VIEW EmployeeName AS
SELECT h.BusinessEntityID, p.LastName, p.FirstName
FROM HumanResources.Employee AS h
JOIN Person.Person AS p
  ON h.BusinessEntityID = p.BusinessEntityID;
GO
</code></pre>
<p>Based on this view, both of these Transact-SQL statements perform the same operations on the base tables and produce the same results:</p>
<pre><code class="lang-sql">/* SELECT referencing the EmployeeName view. */
SELECT LastName AS EmployeeLastName, SalesOrderID, OrderDate
FROM AdventureWorks2022.Sales.SalesOrderHeader AS soh
JOIN AdventureWorks2022.dbo.EmployeeName AS EmpN
  ON (soh.SalesPersonID = EmpN.BusinessEntityID)
WHERE OrderDate &gt; '20020531';

/* SELECT referencing the Person and Employee tables directly. */
SELECT LastName AS EmployeeLastName, SalesOrderID, OrderDate
FROM AdventureWorks2022.HumanResources.Employee AS e
JOIN AdventureWorks2022.Sales.SalesOrderHeader AS soh
  ON soh.SalesPersonID = e.BusinessEntityID
JOIN AdventureWorks2022.Person.Person AS p
  ON e.BusinessEntityID =p.BusinessEntityID
WHERE OrderDate &gt; '20020531';
</code></pre>
<p>The SQL Server Management Studio Showplan feature shows that the relational engine builds the same execution plan for both of these <code>SELECT</code> statements.</p>
<h3 id="use-hints-with-views">Use hints with views</h3>
<p>Hints that are placed on views in a query might conflict with other hints that are discovered when the view is expanded to access its base tables. When this occurs, the query returns an error. For example, consider the following view that contains a table hint in its definition:</p>
<pre><code class="lang-sql">USE AdventureWorks2022;
GO
CREATE VIEW Person.AddrState WITH SCHEMABINDING AS
SELECT a.AddressID, a.AddressLine1,
    s.StateProvinceCode, s.CountryRegionCode
FROM Person.Address a WITH (NOLOCK), Person.StateProvince s
WHERE a.StateProvinceID = s.StateProvinceID;
</code></pre>
<p>Now suppose you enter this query:</p>
<pre><code class="lang-sql">SELECT AddressID, AddressLine1, StateProvinceCode, CountryRegionCode
FROM Person.AddrState WITH (SERIALIZABLE)
WHERE StateProvinceCode = 'WA';
</code></pre>
<p>The query fails, because the hint <code>SERIALIZABLE</code> that is applied on view <code>Person.AddrState</code> in the query is propagated to both tables <code>Person.Address</code> and <code>Person.StateProvince</code> in the view when it is expanded. However, expanding the view also reveals the <code>NOLOCK</code> hint on <code>Person.Address</code>. Because the <code>SERIALIZABLE</code> and <code>NOLOCK</code> hints conflict, the resulting query is incorrect.</p>
<p>The <code>PAGLOCK</code>, <code>NOLOCK</code>, <code>ROWLOCK</code>, <code>TABLOCK</code>, or <code>TABLOCKX</code> table hints conflict with each other, as do the <code>HOLDLOCK</code>, <code>NOLOCK</code>, <code>READCOMMITTED</code>, <code>REPEATABLEREAD</code>, <code>SERIALIZABLE</code> table hints.</p>
<p>Hints can propagate through levels of nested views. For example, suppose a query applies the <code>HOLDLOCK</code> hint on a view <code>v1</code>. When <code>v1</code> is expanded, we find that view <code>v2</code> is part of its definition. <code>v2</code>'s definition includes a <code>NOLOCK</code> hint on one of its base tables. But this table also inherits the <code>HOLDLOCK</code> hint from the query on view <code>v1</code>. Because the <code>NOLOCK</code> and <code>HOLDLOCK</code> hints conflict, the query fails.</p>
<p>When the <code>FORCE ORDER</code> hint is used in a query that contains a view, the join order of the tables within the view is determined by the position of the view in the ordered construct. For example, the following query selects from three tables and a view:</p>
<pre><code class="lang-sql">SELECT * FROM Table1, Table2, View1, Table3
WHERE Table1.Col1 = Table2.Col1
    AND Table2.Col1 = View1.Col1
    AND View1.Col2 = Table3.Col2;
OPTION (FORCE ORDER);
</code></pre>
<p>And <code>View1</code> is defined as shown in the following:</p>
<pre><code class="lang-sql">CREATE VIEW View1 AS
SELECT Colx, Coly FROM TableA, TableB
WHERE TableA.ColZ = TableB.Colz;
</code></pre>
<p>The join order in the query plan is <code>Table1</code>, <code>Table2</code>, <code>TableA</code>, <code>TableB</code>, <code>Table3</code>.</p>
<h3 id="resolve-indexes-on-views">Resolve indexes on views</h3>
<p>As with any index, SQL Server chooses to use an indexed view in its query plan only if the Query Optimizer determines it is beneficial to do so.</p>
<p>Indexed views can be created in any edition of SQL Server. In some editions of some older versions of SQL Server, the Query Optimizer automatically considers the indexed view. In some editions of some older versions of SQL Server, to use an indexed view, the <code>NOEXPAND</code> table hint must be used. Automatic use of an indexed view by the query optimizer is supported only in specific editions of SQL Server. Azure SQL Database and Azure SQL Managed Instance also support automatic use of indexed views without specifying the <code>NOEXPAND</code> hint.</p>
<p>The SQL Server Query Optimizer uses an indexed view when the following conditions are met:</p>
<ul>
<li>These session options are set to <code>ON</code>:
<ul>
<li><code>ANSI_NULLS</code></li>
<li><code>ANSI_PADDING</code></li>
<li><code>ANSI_WARNINGS</code></li>
<li><code>ARITHABORT</code></li>
<li><code>CONCAT_NULL_YIELDS_NULL</code></li>
<li><code>QUOTED_IDENTIFIER</code></li>
</ul>
</li>
<li>The <code>NUMERIC_ROUNDABORT</code> session option is set to OFF.</li>
<li>The Query Optimizer finds a match between the view index columns and elements in the query, such as the following:
<ul>
<li>Search condition predicates in the WHERE clause</li>
<li>Join operations</li>
<li>Aggregate functions</li>
<li><code>GROUP BY</code> clauses</li>
<li>Table references</li>
</ul>
</li>
<li>The estimated cost for using the index has the lowest cost of any access mechanisms considered by the Query Optimizer.</li>
<li>Every table referenced in the query (either directly, or by expanding a view to access its underlying tables) that corresponds to a table reference in the indexed view must have the same set of hints applied on it in the query.</li>
</ul>
<div class="NOTE">
<p>Note</p>
<p>The <code>READCOMMITTED</code> and <code>READCOMMITTEDLOCK</code> hints are always considered different hints in this context, regardless of the current transaction isolation level.</p>
</div>
<p>Other than the requirements for the <code>SET</code> options and table hints, these are the same rules that the Query Optimizer uses to determine whether a table index covers a query. Nothing else has to be specified in the query for an indexed view to be used.</p>
<p>A query doesn't have to explicitly reference an indexed view in the <code>FROM</code> clause for the Query Optimizer to use the indexed view. If the query contains references to columns in the base tables that are also present in the indexed view, and the Query Optimizer estimates that using the indexed view provides the lowest cost access mechanism, the Query Optimizer chooses the indexed view, similar to the way it chooses base table indexes when they aren't directly referenced in a query. The Query Optimizer can choose the view when it contains columns that aren't referenced by the query, as long as the view offers the lowest cost option for covering one or more of the columns specified in the query.</p>
<p>The Query Optimizer treats an indexed view referenced in the <code>FROM</code> clause as a standard view. The Query Optimizer expands the definition of the view into the query at the start of the optimization process. Then, indexed view matching is performed. The indexed view can be used in the final execution plan selected by the Query Optimizer, or instead, the plan might materialize necessary data from the view by accessing the base tables referenced by the view. The Query Optimizer chooses the lowest-cost alternative.</p>
<h4 id="use-hints-with-indexed-views">Use hints with indexed views</h4>
<p>You can prevent view indexes from being used for a query by using the <code>EXPAND VIEWS</code> query hint, or you can use the <code>NOEXPAND</code> table hint to force the use of an index for an indexed view specified in the <code>FROM</code> clause of a query. However, you should let the Query Optimizer dynamically determine the best access methods to use for each query. Limit your use of <code>EXPAND</code> and <code>NOEXPAND</code> to specific cases where testing has shown that they improve performance significantly.</p>
<ul>
<li><p>The <code>EXPAND VIEWS</code> option specifies that the Query Optimizer not use any view indexes for the whole query.</p>
</li>
<li><p>When <code>NOEXPAND</code> is specified for a view, the Query Optimizer considers using any indexes defined on the view. <code>NOEXPAND</code> specified with the optional <code>INDEX()</code> clause forces the Query Optimizer to use the specified indexes. <code>NOEXPAND</code> can be specified only for an indexed view and can't be specified for a view not indexed. Automatic use of an indexed view by the query optimizer is supported only in specific editions of SQL Server. Azure SQL Database and Azure SQL Managed Instance also support automatic use of indexed views without specifying the <code>NOEXPAND</code> hint.</p>
</li>
</ul>
<p>When neither <code>NOEXPAND</code> nor <code>EXPAND VIEWS</code> is specified in a query that contains a view, the view is expanded to access underlying tables. If the query that makes up the view contains any table hints, these hints are propagated to the underlying tables. (This process is explained in more detail in View Resolution.) As long as the set of hints that exists on the underlying tables of the view are identical to each other, the query is eligible to be matched with an indexed view. Most of the time, these hints will match each other, because they are being inherited directly from the view. However, if the query references tables instead of views, and the hints applied directly on these tables aren't identical, then such a query isn't eligible for matching with an indexed view. If the <code>INDEX</code>, <code>PAGLOCK</code>, <code>ROWLOCK</code>, <code>TABLOCKX</code>, <code>UPDLOCK</code>, or <code>XLOCK</code> hints apply to the tables referenced in the query after view expansion, the query isn't eligible for indexed view matching.</p>
<p>If a table hint in the form of <code>INDEX (index_val[ ,...n] )</code> references a view in a query and you don't also specify the <code>NOEXPAND</code> hint, the index hint is ignored. To specify use of a particular index, use <code>NOEXPAND</code>.</p>
<p>Generally, when the Query Optimizer matches an indexed view to a query, any hints specified on the tables or views in the query are applied directly to the indexed view. If the Query Optimizer chooses not to use an indexed view, any hints are propagated directly to the tables referenced in the view. For more information, see View Resolution. This propagation doesn't apply to join hints. They are applied only in their original position in the query. Join hints aren't considered by the Query Optimizer when matching queries to indexed views. If a query plan uses an indexed view that matches part of a query that contains a join hint, the join hint isn't used in the plan.</p>
<p>Hints aren't allowed in the definitions of indexed views. In compatibility mode 80 and higher, SQL Server ignores hints inside indexed view definitions when maintaining them, or when executing queries that use indexed views. Although using hints in indexed view definitions won't produce a syntax error in 80 compatibility mode, they are ignored.</p>
<p>For more information, see <a href="../t-sql/queries/hints-transact-sql-table?view=sql-server-ver17#using-noexpand" data-linktype="relative-path">Table Hints (Transact-SQL)</a>.</p>
<h3 id="resolve-distributed-partitioned-views">Resolve distributed partitioned views</h3>
<p>The SQL Server query processor optimizes the performance of distributed partitioned views. The most important aspect of distributed partitioned view performance is minimizing the amount of data transferred between member servers.</p>
<p>SQL Server builds intelligent, dynamic plans that make efficient use of distributed queries to access data from remote member tables:</p>
<ul>
<li>The Query Processor first uses OLE DB to retrieve the check constraint definitions from each member table. This allows the query processor to map the distribution of key values across the member tables.</li>
<li>The Query Processor compares the key ranges specified in an Transact-SQL statement <code>WHERE</code> clause to the map that shows how the rows are distributed in the member tables. The query processor then builds a query execution plan that uses distributed queries to retrieve only those remote rows that are required to complete the Transact-SQL statement. The execution plan is also built in such a way that any access to remote member tables, for either data or metadata, are delayed until the information is required.</li>
</ul>
<p>For example, consider a system where a <code>Customers</code> table is partitioned across Server1 (<code>CustomerID</code> from 1 through 3299999), Server2 (<code>CustomerID</code> from 3300000 through 6599999), and Server3 (<code>CustomerID</code> from 6600000 through 9999999).</p>
<p>Consider the execution plan built for this query executed on Server1:</p>
<pre><code class="lang-sql">SELECT *
FROM CompanyData.dbo.Customers
WHERE CustomerID BETWEEN 3200000 AND 3400000;
</code></pre>
<p>The execution plan for this query extracts the rows with <code>CustomerID</code> key values from 3200000 through 3299999 from the local member table, and issues a distributed query to retrieve the rows with key values from 3300000 through 3400000 from Server2.</p>
<p>The SQL Server Query Processor can also build dynamic logic into query execution plans for Transact-SQL statements in which the key values aren't known when the plan must be built. For example, consider this stored procedure:</p>
<pre><code class="lang-sql">CREATE PROCEDURE GetCustomer @CustomerIDParameter INT
AS
SELECT *
FROM CompanyData.dbo.Customers
WHERE CustomerID = @CustomerIDParameter;
</code></pre>
<p>SQL Server can't predict what key value will be supplied by the <code>@CustomerIDParameter</code> parameter every time the procedure is executed. Because the key value can't be predicted, the query processor also can't predict which member table will have to be accessed. To handle this case, SQL Server builds an execution plan that has conditional logic, referred to as dynamic filters, to control which member table is accessed, based on the input parameter value. Assuming the <code>GetCustomer</code> stored procedure was executed on Server1, the execution plan logic can be represented as shown in the following:</p>
<pre><code class="lang-output">IF @CustomerIDParameter BETWEEN 1 and 3299999
   Retrieve row from local table CustomerData.dbo.Customer_33
ELSE IF @CustomerIDParameter BETWEEN 3300000 and 6599999
   Retrieve row from linked table Server2.CustomerData.dbo.Customer_66
ELSE IF @CustomerIDParameter BETWEEN 6600000 and 9999999
   Retrieve row from linked table Server3.CustomerData.dbo.Customer_99
</code></pre>
<p>SQL Server sometimes builds these types of dynamic execution plans even for queries that aren't parameterized. The Query Optimizer can parameterize a query so that the execution plan can be reused. If the Query Optimizer parameterizes a query referencing a partitioned view, the Query Optimizer can no longer assume the required rows will come from a specified base table. It will then have to use dynamic filters in the execution plan.</p>
<h2 id="stored-procedure-and-trigger-execution">Stored procedure and trigger execution</h2>
<p>SQL Server stores only the source for stored procedures and triggers. When a stored procedure or trigger is first executed, the source is compiled into an execution plan. If the stored procedure or trigger is again executed before the execution plan is aged from memory, the relational engine detects the existing plan and reuses it. If the plan has aged out of memory, a new plan is built. This process is similar to the process SQL Server follows for all Transact-SQL statements. The main performance advantage that stored procedures and triggers have in SQL Server compared with batches of dynamic Transact-SQL is that their Transact-SQL statements are always the same. Therefore, the relational engine easily matches them with any existing execution plans. Stored procedure and trigger plans are easily reused.</p>
<p>The execution plan for stored procedures and triggers is executed separately from the execution plan for the batch calling the stored procedure or firing the trigger. This allows for greater reuse of the stored procedure and trigger execution plans.</p>
<h2 id="execution-plan-caching-and-reuse">Execution plan caching and reuse</h2>
<p>SQL Server has a pool of memory that is used to store both execution plans and data buffers. The percentage of the pool allocated to either execution plans or data buffers fluctuates dynamically, depending on the state of the system. The part of the memory pool that is used to store execution plans is referred to as the plan cache.</p>
<p>The plan cache has two stores for all compiled plans:</p>
<ul>
<li>The <strong>Object Plans</strong> cache store (OBJCP) used for plans related to persisted objects (stored procedures, functions, and triggers).</li>
<li>The <strong>SQL Plans</strong> cache store (SQLCP) used for plans related to autoparameterized, dynamic, or prepared queries.</li>
</ul>
<p>The query below provides information about memory usage for these two cache stores:</p>
<pre><code class="lang-sql">SELECT * FROM sys.dm_os_memory_clerks
WHERE name LIKE '%plans%';
</code></pre>
<div class="NOTE">
<p>Note</p>
<p>The plan cache has two additional stores that aren't used for storing plans:</p>
<ul>
<li>The <strong>Bound Trees</strong> cache store (PHDR) used for data structures used during plan compilation for views, constraints, and defaults. These structures are known as Bound Trees or Algebrizer Trees.</li>
<li>The <strong>Extended Stored Procedures</strong> cache store (XPROC) used for predefined system procedures, like <code>sp_executeSql</code> or <code>xp_cmdshell</code>, that are defined using a DLL, not using Transact-SQL statements. The cached structure contains only the function name and the DLL name in which the procedure is implemented.</li>
</ul>
</div>
<p>SQL Server execution plans have the following main components:</p>
<ul>
<li><p><strong>Compiled Plan</strong> (or Query Plan)<br>
The query plan produced by the compilation process is mostly a re-entrant, read-only data structure used by any number of users. It stores information about:</p>
<ul>
<li><p>Physical operators that implement the operation described by logical operators.</p>
</li>
<li><p>The order of these operators, which determines the order in which data is accessed, filtered, and aggregated.</p>
</li>
<li><p>The number of estimated rows flowing through the operators.</p>
<div class="NOTE">
<p>Note</p>
<p>In newer versions of the Database Engine, information about the statistics objects that were used for <a href="performance/cardinality-estimation-sql-server?view=sql-server-ver17" data-linktype="relative-path">Cardinality Estimation</a> is also stored.</p>
</div>
</li>
<li><p>What support objects must be created, such as <a href="#worktables" data-linktype="self-bookmark">worktables</a> or workfiles in <code>tempdb</code>.
No user context or runtime information is stored in the query plan. There are never more than one or two copies of the query plan in memory: one copy for all serial executions and another for all parallel executions. The parallel copy covers all parallel executions, regardless of their degree of parallelism.</p>
</li>
</ul>
</li>
<li><p><strong>Execution Context</strong><br>
Each user that is currently executing the query has a data structure that holds the data specific to their execution, such as parameter values. This data structure is referred to as the execution context. The execution context data structures are reused, but their content isn't. If another user executes the same query, the data structures are reinitialized with the context for the new user.</p>
<p><span class="mx-imgBorder">
<img src="media/query-processing-architecture-guide/execution-context.gif?view=sql-server-ver17" alt="Diagram of the Execution context." data-linktype="relative-path">
</span>
</p>
</li>
</ul>
<p>When any Transact-SQL statement is executed in SQL Server, the Database Engine first looks through the plan cache to verify that an existing execution plan for the same Transact-SQL statement exists. The Transact-SQL statement qualifies as existing if it literally matches a previously executed Transact-SQL statement with a cached plan, character per character. SQL Server reuses any existing plan it finds, saving the overhead of recompiling the Transact-SQL statement. If no execution plan exists, SQL Server generates a new execution plan for the query.</p>
<div class="NOTE">
<p>Note</p>
<p>The execution plans for some Transact-SQL statements aren't persisted in the plan cache, such as bulk operation statements running on rowstore or statements containing string literals larger than 8 KB in size. These plans only exist while the query is being executed.</p>
</div>
<p>SQL Server has an efficient algorithm to find any existing execution plans for any specific Transact-SQL statement. In most systems, the minimal resources that are used by this scan are less than the resources that are saved by being able to reuse existing plans instead of compiling every Transact-SQL statement.</p>
<p>The algorithms to match new Transact-SQL statements to existing, unused execution plans in the plan cache require that all object references be fully qualified. For example, assume that <code>Person</code> is the default schema for the user executing the below <code>SELECT</code> statements. While in this example it isn't required that the <code>Person</code> table is fully qualified to execute, it means that the second statement isn't matched with an existing plan, but the third is matched:</p>
<pre><code class="lang-sql">USE AdventureWorks2022;
GO
SELECT * FROM Person;
GO
SELECT * FROM Person.Person;
GO
SELECT * FROM Person.Person;
GO
</code></pre>
<p>Changing any of the following SET options for a given execution will affect the ability to reuse plans, because the Database Engine performs <a href="#constant-folding-and-expression-evaluation" data-linktype="self-bookmark">constant folding</a> and these options affect the results of such expressions:</p>
<section class="row">
<div class="column">
<p>ANSI_NULL_DFLT_OFF</p>
</div>
<div class="column">
<p>FORCEPLAN</p>
</div>
<div class="column">
<p>ARITHABORT</p>
</div>
</section>
<section class="row">
<div class="column">
<p>DATEFIRST</p>
</div>
<div class="column">
<p>ANSI_PADDING</p>
</div>
<div class="column">
<p>NUMERIC_ROUNDABORT</p>
</div>
</section>
<section class="row">
<div class="column">
<p>ANSI_NULL_DFLT_ON</p>
</div>
<div class="column">
<p>LANGUAGE</p>
</div>
<div class="column">
<p>CONCAT_NULL_YIELDS_NULL</p>
</div>
</section>
<section class="row">
<div class="column">
<p>DATEFORMAT</p>
</div>
<div class="column">
<p>ANSI_WARNINGS</p>
</div>
<div class="column">
<p>QUOTED_IDENTIFIER</p>
</div>
</section>
<section class="row">
<div class="column">
<p>ANSI_NULLS</p>
</div>
<div class="column">
<p>NO_BROWSETABLE</p>
</div>
<div class="column">
<p>ANSI_DEFAULTS</p>
</div>
</section>
<h3 id="cache-multiple-plans-for-the-same-query">Cache multiple plans for the same query</h3>
<p>Queries and execution plans are uniquely identifiable in the Database Engine, much like a fingerprint:</p>
<ul>
<li>The <strong>query plan hash</strong> is a binary hash value calculated on the execution plan for a given query, and used to uniquely identify similar execution plans.</li>
<li>The <strong>query hash</strong> is a binary hash value calculated on the Transact-SQL text of a query, and is used to uniquely identify queries.</li>
</ul>
<p>A compiled plan can be retrieved from the plan cache using a <strong>Plan Handle</strong>, which is a transient identifier that remains constant only while the plan remains in the cache. The plan handle is a hash value derived from the compiled plan of the entire batch. The plan handle for a compiled plan remains the same even if one or more statements in the batch get recompiled.</p>
<div class="NOTE">
<p>Note</p>
<p>If a plan was compiled for a batch instead of a single statement, the plan for individual statements in the batch can be retrieved using the plan handle and statement offsets.
The <code>sys.dm_exec_requests</code> DMV contains the <code>statement_start_offset</code> and <code>statement_end_offset</code> columns for each record, which refer to the currently executing statement of a currently executing batch or persisted object. For more information, see <a href="system-dynamic-management-views/sys-dm-exec-requests-transact-sql?view=sql-server-ver17" data-linktype="relative-path">sys.dm_exec_requests  (Transact-SQL)</a>.
The <code>sys.dm_exec_query_stats</code> DMV also contains these columns for each record, which refer to the position of a statement within a batch or persisted object. For more information, see <a href="system-dynamic-management-views/sys-dm-exec-query-stats-transact-sql?view=sql-server-ver17" data-linktype="relative-path">sys.dm_exec_query_stats (Transact-SQL)</a>.</p>
</div>
<p>The actual Transact-SQL text of a batch is stored in a separate memory space from the plan cache, called the <strong>SQL Manager</strong> cache (SQLMGR). The Transact-SQL text for a compiled plan can be retrieved from the sql manager cache using a <strong>SQL Handle</strong>, which is a transient identifier that remains constant only while at least one plan that references it remains in the plan cache. The sql handle is a hash value derived from the entire batch text and is guaranteed to be unique for every batch.</p>
<div class="NOTE">
<p>Note</p>
<p>Like a compiled plan, the Transact-SQL text is stored per batch, including the comments. The sql handle contains the MD5 hash of the entire batch text and is guaranteed to be unique for every batch.</p>
</div>
<p>The query below provides information about memory usage for the sql manager cache:</p>
<pre><code class="lang-sql">SELECT * FROM sys.dm_os_memory_objects
WHERE type = 'MEMOBJ_SQLMGR';
</code></pre>
<p>There is a 1:N relation between a sql handle and plan handles. Such a condition occurs when the cache key for the compiled plans is different. This might occur due to change in SET options between two executions of the same batch.</p>
<p>Consider the following stored procedure:</p>
<pre><code class="lang-sql">USE WideWorldImporters;
GO
CREATE PROCEDURE usp_SalesByCustomer @CID int
AS
SELECT * FROM Sales.Customers
WHERE CustomerID = @CID
GO

SET ANSI_DEFAULTS ON
GO

EXEC usp_SalesByCustomer 10
GO
</code></pre>
<p>Verify what can be found in the plan cache using the query below:</p>
<pre><code class="lang-sql">SELECT cp.memory_object_address, cp.objtype, refcounts, usecounts,
    qs.query_plan_hash, qs.query_hash,
    qs.plan_handle, qs.sql_handle
FROM sys.dm_exec_cached_plans AS cp
CROSS APPLY sys.dm_exec_sql_text (cp.plan_handle)
CROSS APPLY sys.dm_exec_query_plan (cp.plan_handle)
INNER JOIN sys.dm_exec_query_stats AS qs ON qs.plan_handle = cp.plan_handle
WHERE text LIKE '%usp_SalesByCustomer%'
GO
</code></pre>
<p>Here's the result set.</p>
<pre><code class="lang-output">memory_object_address    objtype   refcounts   usecounts   query_plan_hash    query_hash
---------------------   -------  ---------  ---------  ------------------ ------------------
0x000001CC6C534060        Proc      2           1           0x3B4303441A1D7E6D 0xA05D5197DA1EAC2D

plan_handle
------------------------------------------------------------------------------------------
0x0500130095555D02D022F111CD01000001000000000000000000000000000000000000000000000000000000

sql_handle
------------------------------------------------------------------------------------------
0x0300130095555D02C864C10061AB000001000000000000000000000000000000000000000000000000000000
</code></pre>
<p>Now execute the stored procedure with a different parameter, but no other changes to execution context:</p>
<pre><code class="lang-sql">EXEC usp_SalesByCustomer 8
GO
</code></pre>
<p>Verify again what can be found in the plan cache. Here's the result set.</p>
<pre><code class="lang-output">memory_object_address    objtype   refcounts   usecounts   query_plan_hash    query_hash
---------------------   -------  ---------  ---------  ------------------ ------------------
0x000001CC6C534060        Proc      2           2           0x3B4303441A1D7E6D 0xA05D5197DA1EAC2D

plan_handle
------------------------------------------------------------------------------------------
0x0500130095555D02D022F111CD01000001000000000000000000000000000000000000000000000000000000

sql_handle
------------------------------------------------------------------------------------------
0x0300130095555D02C864C10061AB000001000000000000000000000000000000000000000000000000000000
</code></pre>
<p>Notice the <code>usecounts</code> has increased to 2, which means the same cached plan was reused as-is, because the execution context data structures were reused. Now change the <code>SET ANSI_DEFAULTS</code> option and execute the stored procedure using the same parameter.</p>
<pre><code class="lang-sql">SET ANSI_DEFAULTS OFF
GO

EXEC usp_SalesByCustomer 8
GO
</code></pre>
<p>Verify again what can be found in the plan cache. Here's the result set.</p>
<pre><code class="lang-output">memory_object_address    objtype   refcounts   usecounts   query_plan_hash    query_hash
---------------------   -------  ---------  ---------  ------------------ ------------------
0x000001CD01DEC060        Proc      2           1           0x3B4303441A1D7E6D 0xA05D5197DA1EAC2D
0x000001CC6C534060        Proc      2           2           0x3B4303441A1D7E6D 0xA05D5197DA1EAC2D

plan_handle
------------------------------------------------------------------------------------------
0x0500130095555D02B031F111CD01000001000000000000000000000000000000000000000000000000000000
0x0500130095555D02D022F111CD01000001000000000000000000000000000000000000000000000000000000

sql_handle
------------------------------------------------------------------------------------------
0x0300130095555D02C864C10061AB000001000000000000000000000000000000000000000000000000000000
0x0300130095555D02C864C10061AB000001000000000000000000000000000000000000000000000000000000
</code></pre>
<p>Notice there are now two entries in the <code>sys.dm_exec_cached_plans</code> DMV output:</p>
<ul>
<li>The <code>usecounts</code> column shows the value <code>1</code> in the first record, which is the plan executed once with <code>SET ANSI_DEFAULTS OFF</code>.</li>
<li>The <code>usecounts</code> column shows the value <code>2</code> in the second record, which is the plan executed with <code>SET ANSI_DEFAULTS ON</code>, because it was executed twice.</li>
<li>The different <code>memory_object_address</code> refers to a different execution plan entry in the plan cache. However, the <code>sql_handle</code> value is the same for both entries because they refer to the same batch.
<ul>
<li>The execution with <code>ANSI_DEFAULTS</code> set to OFF has a new <code>plan_handle</code>, and it's available for reuse for calls that have the same set of SET options. The new plan handle is necessary because the execution context was reinitialized due to changed SET options. But that doesn't trigger a recompile: both entries refer to the same plan and query, as evidenced by the same <code>query_plan_hash</code> and <code>query_hash</code> values.</li>
</ul>
</li>
</ul>
<p>What this effectively means is that we have two plan entries in the cache corresponding to the same batch, and it underscores the importance of making sure that the plan cache affecting SET options are the same, when the same queries are executed repeatedly, to optimize for plan reuse and keep plan cache size to its required minimum.</p>
<div class="TIP">
<p>Tip</p>
<p>A common pitfall is that different clients can have different default values for the SET options. For example, a connection made through SQL Server Management Studio automatically sets <code>QUOTED_IDENTIFIER</code> to ON, while SQLCMD sets <code>QUOTED_IDENTIFIER</code> to OFF. Executing the same queries from these two clients will result in multiple plans (as described in the example above).</p>
</div>
<h3 id="remove-execution-plans-from-the-plan-cache">Remove execution plans from the plan cache</h3>
<p>Execution plans remain in the plan cache as long as there is enough memory to store them. When memory pressure exists, the SQL Server Database Engine uses a cost-based approach to determine which execution plans to remove from the plan cache. To make a cost-based decision, the SQL Server Database Engine increases and decreases a current cost variable for each execution plan according to the following factors.</p>
<p>When a user process inserts an execution plan into the cache, the user process sets the current cost equal to the original query compile cost; for ad hoc execution plans, the user process sets the current cost to zero. Thereafter, each time a user process references an execution plan, it resets the current cost to the original compile cost; for ad hoc execution plans the user process increases the current cost. For all plans, the maximum value for the current cost is the original compile cost.</p>
<p>When memory pressure exists, the SQL Server Database Engine responds by removing execution plans from the plan cache. To determine which plans to remove, the SQL Server Database Engine repeatedly examines the state of each execution plan and removes plans when their current cost is zero. An execution plan with zero current cost isn't removed automatically when memory pressure exists; it is removed only when the SQL Server Database Engine examines the plan and the current cost is zero. When examining an execution plan, the SQL Server Database Engine pushes the current cost toward zero by decreasing the current cost if a query isn't currently using the plan.</p>
<p>The SQL Server Database Engine repeatedly examines the execution plans until enough have been removed to satisfy memory requirements. While memory pressure exists, an execution plan might have its cost increased and decreased more than once. When memory pressure no longer exists, the SQL Server Database Engine stops decreasing the current cost of unused execution plans and all execution plans remain in the plan cache, even if their cost is zero.</p>
<p>The SQL Server Database Engine uses the resource monitor and user worker threads to free memory from the plan cache in response to memory pressure. The resource monitor and user worker threads can examine plans run concurrently to decrease the current cost for each unused execution plan. The resource monitor removes execution plans from the plan cache when global memory pressure exists. It frees memory to enforce policies for system memory, process memory, resource pool memory, and maximum size for all caches.</p>
<p>The maximum size for all caches is a function of the buffer pool size and can't exceed the maximum server memory. For more information on configuring the maximum server memory, see the <code>max server memory</code> setting in <code>sp_configure</code>.</p>
<p>The user worker threads remove execution plans from the plan cache when single cache memory pressure exists. They enforce policies for maximum single cache size and maximum single cache entries.</p>
<p>The following examples illustrate which execution plans get removed from the plan cache:</p>
<ul>
<li>An execution plan is frequently referenced so that its cost never goes to zero. The plan remains in the plan cache and isn't removed unless there is memory pressure and the current cost is zero.</li>
<li>An ad hoc execution plan is inserted and isn't referenced again before memory pressure exists. Since ad hoc plans are initialized with a current cost of zero, when the SQL Server Database Engine examines the execution plan, it will see the zero current cost and remove the plan from the plan cache. The ad hoc execution plan remains in the plan cache with a zero current cost when memory pressure doesn't exist.</li>
</ul>
<p>To manually remove a single plan or all plans from the cache, use <a href="../t-sql/database-console-commands/dbcc-freeproccache-transact-sql?view=sql-server-ver17" data-linktype="relative-path">DBCC FREEPROCCACHE</a>. <a href="../t-sql/database-console-commands/dbcc-freesystemcache-transact-sql?view=sql-server-ver17" data-linktype="relative-path">DBCC FREESYSTEMCACHE</a> can also be used to clear any cache, including plan cache. Starting with SQL Server 2016 (13.x), the <code>ALTER DATABASE SCOPED CONFIGURATION CLEAR PROCEDURE_CACHE</code> to clear the procedure (plan) cache for the database in scope.</p>
<p>A change in some configuration settings via <a href="system-stored-procedures/sp-configure-transact-sql?view=sql-server-ver17" data-linktype="relative-path">sp_configure</a> and <a href="../t-sql/language-elements/reconfigure-transact-sql?view=sql-server-ver17" data-linktype="relative-path">reconfigure</a> will also cause plans to be removed from plan cache. You can find the list of these configuration settings in the Remarks section of the <a href="../t-sql/database-console-commands/dbcc-freeproccache-transact-sql?view=sql-server-ver17#remarks" data-linktype="relative-path">DBCC FREEPROCCACHE</a> article. A configuration change like this will log the following informational message in the error log:</p>
<blockquote>
<p><code>SQL Server has encountered %d occurrence(s) of cachestore flush for the '%s' cachestore (part of plan cache) due to some database maintenance or reconfigure operations.</code></p>
</blockquote>
<h3 id="recompiling-execution-plans"> Recompile execution plans</h3>
<p>Certain changes in a database can cause an execution plan to be either inefficient or invalid, based on the new state of the database. SQL Server detects the changes that invalidate an execution plan and marks the plan as not valid. A new plan must then be recompiled for the next connection that executes the query. The conditions that invalidate a plan include the following:</p>
<ul>
<li>Changes made to a table or view referenced by the query (<code>ALTER TABLE</code> and <code>ALTER VIEW</code>).</li>
<li>Changes made to a single procedure, which would drop all plans for that procedure from the cache (<code>ALTER PROCEDURE</code>).</li>
<li>Changes to any indexes used by the execution plan.</li>
<li>Updates on statistics used by the execution plan, generated either explicitly from a statement, such as <code>UPDATE STATISTICS</code>, or generated automatically.</li>
<li>Dropping an index used by the execution plan.</li>
<li>An explicit call to <code>sp_recompile</code>.</li>
<li>Large numbers of changes to keys (generated by <code>INSERT</code> or <code>DELETE</code> statements from other users that modify a table referenced by the query).</li>
<li>For tables with triggers, if the number of rows in the inserted or deleted tables grows significantly.</li>
<li>Executing a stored procedure using the <code>WITH RECOMPILE</code> option.</li>
</ul>
<p>Most recompilations are required either for statement correctness or to obtain potentially faster query execution plans.</p>
<p>In SQL Server versions prior to 2005, whenever a statement within a batch causes recompilation, the entire batch, whether submitted through a stored procedure, trigger, ad hoc batch, or prepared statement, was recompiled. Starting with SQL Server 2005 (9.x), only the statement inside the batch that triggers recompilation is recompiled. Also, there are additional types of recompilations in SQL Server 2005 (9.x) and later because of its expanded feature set.</p>
<p>Statement-level recompilation benefits performance because, in most cases, a small number of statements causes recompilations and their associated penalties, in terms of CPU time and locks. These penalties are therefore avoided for the other statements in the batch that don't have to be recompiled.</p>
<p>The <code>sql_statement_recompile</code> extended event (XEvent) reports statement-level recompilations. This XEvent occurs when a statement-level recompilation is required by any kind of batch. This includes stored procedures, triggers, ad hoc batches and queries. Batches can be submitted through several interfaces, including <code>sp_executesql</code>, dynamic SQL, Prepare methods or Execute methods.</p>
<p>The <code>recompile_cause</code> column of <code>sql_statement_recompile</code> XEvent contains an integer code that indicates the reason for the recompilation. The following table contains the possible reasons:</p>
<section class="row">
<div class="column">
<p>Schema changed</p>
</div>
<div class="column">
<p>Statistics changed</p>
</div>
</section>
<section class="row">
<div class="column">
<p>Deferred compile</p>
</div>
<div class="column">
<p>SET option changed</p>
</div>
</section>
<section class="row">
<div class="column">
<p>Temporary table changed</p>
</div>
<div class="column">
<p>Remote rowset changed</p>
</div>
</section>
<section class="row">
<div class="column">
<p><code>FOR BROWSE</code> permission changed</p>
</div>
<div class="column">
<p>Query notification environment changed</p>
</div>
</section>
<section class="row">
<div class="column">
<p>Partitioned view changed</p>
</div>
<div class="column">
<p>Cursor options changed</p>
</div>
</section>
<section class="row">
<div class="column">
<p><code>OPTION (RECOMPILE)</code> requested</p>
</div>
<div class="column">
<p>Parameterized plan flushed</p>
</div>
</section>
<section class="row">
<div class="column">
<p>Plan affecting database version changed</p>
</div>
<div class="column">
<p>Query Store plan forcing policy changed</p>
</div>
</section>
<section class="row">
<div class="column">
<p>Query Store plan forcing failed</p>
</div>
<div class="column">
<p>Query Store missing the plan</p>
</div>
</section>
<div class="NOTE">
<p>Note</p>
<p>In SQL Server versions where XEvents aren't available, then the SQL Server Profiler <a href="event-classes/sp-recompile-event-class?view=sql-server-ver17" data-linktype="relative-path">SP:Recompile</a> trace event can be used for the same purpose of reporting statement-level recompilations.</p>
<p>The trace event <code>SQL:StmtRecompile</code> also reports statement-level recompilations, and this trace event can also be used to track and debug recompilations.</p>
<p>Whereas <code>SP:Recompile</code> generates only for stored procedures and triggers, <code>SQL:StmtRecompile</code> generates for stored procedures, triggers, ad hoc batches, batches that are executed by using <code>sp_executesql</code>, prepared queries, and dynamic SQL.
The <em>EventSubClass</em> column of <code>SP:Recompile</code> and <code>SQL:StmtRecompile</code> contains an integer code that indicates the reason for the recompilation. The codes are described in <a href="event-classes/sql-stmtrecompile-event-class?view=sql-server-ver17" data-linktype="relative-path">SQL:StmtRecompile Event Class</a>.</p>
</div>
<div class="NOTE">
<p>Note</p>
<p>When the <code>AUTO_UPDATE_STATISTICS</code> database option is set to <code>ON</code>, queries are recompiled when they target tables or indexed views whose statistics have been updated or whose cardinalities have changed significantly since the last execution.</p>
<p>This behavior applies to standard user-defined tables, temporary tables, and the inserted and deleted tables created by DML triggers. If query performance is affected by excessive recompilations, consider changing this setting to <code>OFF</code>. When the <code>AUTO_UPDATE_STATISTICS</code> database option is set to <code>OFF</code>, no recompilations occur based on statistics or cardinality changes, with the exception of the inserted and deleted tables that are created by DML <code>INSTEAD OF</code> triggers. Because these tables are created in <code>tempdb</code>, the recompilation of queries that access them depends on the setting of <code>AUTO_UPDATE_STATISTICS</code> in <code>tempdb</code>.</p>
<p>In SQL Server prior to 2005, queries continue to recompile based on cardinality changes to the DML trigger inserted and deleted tables, even when this setting is <code>OFF</code>.</p>
</div>
<h3 id="parameters-and-execution-plan-reuse">Parameters and execution plan reuse</h3>
<p>The use of parameters, including parameter markers in ADO, OLE DB, and ODBC applications, can increase the reuse of execution plans.</p>
<div class="WARNING">
<p>Warning</p>
<p>Using parameters or parameter markers to hold values that are typed by end users is more secure than concatenating the values into a string that is then executed by using either a data access API method, the <code>EXECUTE</code> statement, or the <code>sp_executesql</code> stored procedure.</p>
</div>
<p>The only difference between the following two <code>SELECT</code> statements is the values that are compared in the <code>WHERE</code> clause:</p>
<pre><code class="lang-sql">SELECT *
FROM AdventureWorks2022.Production.Product
WHERE ProductSubcategoryID = 1;
</code></pre>
<pre><code class="lang-sql">SELECT *
FROM AdventureWorks2022.Production.Product
WHERE ProductSubcategoryID = 4;
</code></pre>
<p>The only difference between the execution plans for these queries is the value stored for the comparison against the <code>ProductSubcategoryID</code> column. While the goal is for SQL Server to always recognize that the statements generate essentially the same plan and reuse the plans, SQL Server sometimes doesn't detect this in complex Transact-SQL statements.</p>
<p>Separating constants from the Transact-SQL statement by using parameters helps the relational engine recognize duplicate plans. You can use parameters in the following ways:</p>
<ul>
<li><p>In Transact-SQL , use <code>sp_executesql</code>:</p>
<pre><code class="lang-sql">DECLARE @MyIntParm INT
SET @MyIntParm = 1
EXEC sp_executesql
   N'SELECT *
   FROM AdventureWorks2022.Production.Product
   WHERE ProductSubcategoryID = @Parm',
   N'@Parm INT',
   @MyIntParm
</code></pre>
<p>This method is recommended for Transact-SQL  scripts, stored procedures, or triggers that generate SQL statements dynamically.</p>
</li>
<li><p>ADO, OLE DB, and ODBC use parameter markers. Parameter markers are question marks (?) that replace a constant in a SQL statement and are bound to a program variable. For example, you would do the following in an ODBC application:</p>
<ul>
<li><p>Use <code>SQLBindParameter</code> to bind an integer variable to the first parameter marker in a SQL statement.</p>
</li>
<li><p>Put the integer value in the variable.</p>
</li>
<li><p>Execute the statement, specifying the parameter marker (?):</p>
<pre><code class="lang-vb">SQLExecDirect(hstmt,
  "SELECT *
  FROM AdventureWorks2022.Production.Product
  WHERE ProductSubcategoryID = ?",
  SQL_NTS);
</code></pre>
</li>
</ul>
<p>The SQL Server Native Client OLE DB Provider and the SQL Server Native Client ODBC driver included with SQL Server use <code>sp_executesql</code> to send statements to SQL Server when parameter markers are used in applications.</p>
</li>
<li><p>To design stored procedures, which use parameters by design.</p>
</li>
</ul>
<p>If you don't explicitly build parameters into the design of your applications, you can also rely on the SQL Server Query Optimizer to automatically parameterize certain queries by using the default behavior of simple parameterization. Alternatively, you can force the Query Optimizer to consider parameterizing all queries in the database by setting the <code>PARAMETERIZATION</code> option of the <code>ALTER DATABASE</code> statement to <code>FORCED</code>.</p>
<p>When forced parameterization is enabled, simple parameterization can still occur. For example, the following query can't be parameterized according to the rules of forced parameterization:</p>
<pre><code class="lang-sql">SELECT * FROM Person.Address
WHERE AddressID = 1 + 2;
</code></pre>
<p>However, it can be parameterized according to simple parameterization rules. When forced parameterization is tried but fails, simple parameterization is still subsequently tried.</p>
<h3 id="simple-parameterization">Simple parameterization</h3>
<p>In SQL Server, using parameters or parameter markers in Transact-SQL statements increases the ability of the relational engine to match new Transact-SQL statements with existing, previously compiled execution plans.</p>
<div class="WARNING">
<p>Warning</p>
<p>Using parameters or parameter markers to hold values typed by end users is more secure than concatenating the values into a string that is then executed using either a data access API method, the <code>EXECUTE</code> statement, or the <code>sp_executesql</code> stored procedure.</p>
</div>
<p>If a Transact-SQL statement is executed without parameters, SQL Server parameterizes the statement internally to increase the possibility of matching it against an existing execution plan. This process is called simple parameterization. In SQL Server versions prior to 2005, the process was referred to as auto-parameterization.</p>
<p>Consider this statement:</p>
<pre><code class="lang-sql">SELECT * FROM AdventureWorks2022.Production.Product
WHERE ProductSubcategoryID = 1;
</code></pre>
<p>The value 1 at the end of the statement can be specified as a parameter. The relational engine builds the execution plan for this batch as if a parameter had been specified in place of the value 1. Because of this simple parameterization, SQL Server recognizes that the following two statements generate essentially the same execution plan and reuses the first plan for the second statement:</p>
<pre><code class="lang-sql">SELECT * FROM AdventureWorks2022.Production.Product
WHERE ProductSubcategoryID = 1;
</code></pre>
<pre><code class="lang-sql">SELECT * FROM AdventureWorks2022.Production.Product
WHERE ProductSubcategoryID = 4;
</code></pre>
<p>When processing complex Transact-SQL statements, the relational engine can have difficulty determining which expressions can be parameterized. To increase the ability of the relational engine to match complex Transact-SQL statements to existing, unused execution plans, explicitly specify the parameters using either <code>sp_executesql</code> or parameter markers.</p>
<div class="NOTE">
<p>Note</p>
<p>When the <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, or <code>%</code> arithmetic operators are used to perform implicit or explicit conversion of int, smallint, tinyint, or bigint constant values to the float, real, decimal or numeric data types, SQL Server applies specific rules to calculate the type and precision of the expression results. However, these rules differ, depending on whether the query is parameterized or not. Therefore, similar expressions in queries can, in some cases, produce differing results.</p>
</div>
<p>Under the default behavior of simple parameterization, SQL Server parameterizes a relatively small class of queries. However, you can specify that all queries in a database be parameterized, subject to certain limitations, by setting the <code>PARAMETERIZATION</code> option of the <code>ALTER DATABASE</code> command to <code>FORCED</code>. Doing so can improve the performance of databases that experience high volumes of concurrent queries by reducing the frequency of query compilations.</p>
<p>Alternatively, you can specify that a single query, and any others that are syntactically equivalent but differ only in their parameter values, be parameterized.</p>
<div class="TIP">
<p>Tip</p>
<p>When using an Object-Relational Mapping (ORM) solution such as Entity Framework (EF), application queries like manual LINQ query trees or certain raw SQL queries might not be parameterized, which impacts plan re-use and the ability to track queries in the Query Store. For more information, see <a href="/en-us/ef/core/performance/advanced-performance-topics" data-linktype="absolute-path">EF Query caching and parameterization</a> and <a href="/en-us/ef/core/querying/raw-sql" data-linktype="absolute-path">EF Raw SQL Queries</a>.</p>
</div>
<h3 id="forced-parameterization">Forced parameterization</h3>
<p>You can override the default simple parameterization behavior of SQL Server by specifying that all <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> statements in a database be parameterized, subject to certain limitations. Forced parameterization is enabled by setting the <code>PARAMETERIZATION</code> option to <code>FORCED</code> in the <code>ALTER DATABASE</code> statement. Forced parameterization might improve the performance of certain databases by reducing the frequency of query compilations and recompilations. Databases that might benefit from forced parameterization are generally those that experience high volumes of concurrent queries from sources such as point-of-sale applications.</p>
<p>When the <code>PARAMETERIZATION</code> option is set to <code>FORCED</code>, any literal value that appears in a <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code> statement, submitted in any form, is converted to a parameter during query compilation. The exceptions are literals that appear in the following query constructs:</p>
<ul>
<li><code>INSERT...EXECUTE</code> statements.</li>
<li>Statements inside the bodies of stored procedures, triggers, or user-defined functions. SQL Server already reuses query plans for these routines.</li>
<li>Prepared statements that have already been parameterized on the client-side application.</li>
<li>Statements that contain XQuery method calls, where the method appears in a context where its arguments would typically be parameterized, such as a <code>WHERE</code> clause. If the method appears in a context where its arguments wouldn't be parameterized, the rest of the statement is parameterized.</li>
<li>Statements inside a Transact-SQL cursor. (<code>SELECT</code> statements inside API cursors are parameterized.)</li>
<li>Deprecated query constructs.</li>
<li>Any statement that is run in the context of <code>ANSI_PADDING</code> or <code>ANSI_NULLS</code> set to <code>OFF</code>.</li>
<li>Statements that contain more than 2,097 literals that are eligible for parameterization.</li>
<li>Statements that reference variables, such as <code>WHERE T.col2 &gt;= @bb</code>.</li>
<li>Statements that contain the <code>RECOMPILE</code> query hint.</li>
<li>Statements that contain a <code>COMPUTE</code> clause.</li>
<li>Statements that contain a <code>WHERE CURRENT OF</code> clause.</li>
</ul>
<p>Additionally, the following query clauses aren't parameterized. In these cases, only the clauses aren't parameterized. Other clauses within the same query can be eligible for forced parameterization.</p>
<ul>
<li>The &lt;select_list&gt; of any <code>SELECT</code> statement. This includes <code>SELECT</code> lists of subqueries and <code>SELECT</code> lists inside <code>INSERT</code> statements.</li>
<li>Subquery <code>SELECT</code> statements that appear inside an <code>IF</code> statement.</li>
<li>The <code>TOP</code>, <code>TABLESAMPLE</code>, <code>HAVING</code>, <code>GROUP BY</code>, <code>ORDER BY</code>, <code>OUTPUT...INTO</code>, or <code>FOR XML</code> clauses of a query.</li>
<li>Arguments, either direct or as subexpressions, to <code>OPENROWSET</code>, <code>OPENQUERY</code>, <code>OPENDATASOURCE</code>, <code>OPENXML</code>, or any <code>FULLTEXT</code> operator.</li>
<li>The pattern and escape_character arguments of a <code>LIKE</code> clause.</li>
<li>The style argument of a <code>CONVERT</code> clause.</li>
<li>Integer constants inside an <code>IDENTITY</code> clause.</li>
<li>Constants specified by using ODBC extension syntax.</li>
<li>Constant-foldable expressions that are arguments of the <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, and <code>%</code> operators. When considering eligibility for forced parameterization, SQL Server considers an expression to be constant-foldable when either of the following conditions is true:
<ul>
<li>No columns, variables, or subqueries appear in the expression.</li>
<li>The expression contains a <code>CASE</code> clause.</li>
</ul>
</li>
<li>Arguments to query hint clauses. These include the <em>number_of_rows</em> argument of the <code>FAST</code> query hint, the <em>number_of_processors</em> argument of the <code>MAXDOP</code> query hint, and the <em>number</em> argument of the <code>MAXRECURSION</code> query hint.</li>
</ul>
<p>Parameterization occurs at the level of individual Transact-SQL statements. In other words, individual statements in a batch are parameterized. After compiling, a parameterized query is executed in the context of the batch in which it was originally submitted. If an execution plan for a query is cached, you can determine whether the query was parameterized by referencing the sql column of the <code>sys.syscacheobjects</code> dynamic management view. If a query is parameterized, the names and data types of parameters come before the text of the submitted batch in this column, such as (@1 tinyint).</p>
<div class="NOTE">
<p>Note</p>
<p>Parameter names are arbitrary. Users or applications should not rely on a particular naming order. Also, the following can change between versions of SQL Server and Service Pack upgrades: Parameter names, the choice of literals that are parameterized, and the spacing in the parameterized text.</p>
</div>
<h4 id="data-types-of-parameters">Data types of parameters</h4>
<p>When SQL Server parameterizes literals, the parameters are converted to the following data types:</p>
<ul>
<li>Integer literals whose size would otherwise fit within the int data type parameterize to int. Larger integer literals that are parts of predicates that involve any comparison operator (includes <code>&lt;</code>, <code>&lt;=</code>, <code>=</code>, <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>!&lt;</code>, <code>!&gt;</code>, <code>&lt;&gt;</code>, <code>ALL</code>, <code>ANY</code>, <code>SOME</code>, <code>BETWEEN</code>, and <code>IN</code>) parameterize to numeric(38,0). Larger literals that aren't parts of predicates that involve comparison operators parameterize to numeric whose precision is just large enough to support its size and whose scale is 0.</li>
<li>Fixed-point numeric literals that are parts of predicates that involve comparison operators parameterize to numeric whose precision is 38 and whose scale is just large enough to support its size. Fixed-point numeric literals that aren't parts of predicates that involve comparison operators parameterize to numeric whose precision and scale are just large enough to support its size.</li>
<li>Floating point numeric literals parameterize to float(53).</li>
<li>Non-Unicode string literals parameterize to varchar(8000) if the literal fits within 8,000 characters, and to varchar(max) if it is larger than 8,000 characters.</li>
<li>Unicode string literals parameterize to nvarchar(4000) if the literal fits within 4,000 Unicode characters, and to nvarchar(max) if the literal is larger than 4,000 characters.</li>
<li>Binary literals parameterize to varbinary(8000) if the literal fits within 8,000 bytes. If it is larger than 8,000 bytes, it is converted to varbinary(max).</li>
<li>Money type literals parameterize to money.</li>
</ul>
<h4 id="guidelines-for-using-forced-parameterization">Guidelines for using forced parameterization</h4>
<p>Consider the following when you set the <code>PARAMETERIZATION</code> option to FORCED:</p>
<ul>
<li>Forced parameterization, in effect, changes the literal constants in a query to parameters when compiling a query. Therefore, the Query Optimizer can choose suboptimal plans for queries. In particular, the Query Optimizer is less likely to match the query to an indexed view or an index on a computed column. It might also choose suboptimal plans for queries posed on partitioned tables and distributed partitioned views. Forced parameterization shouldn't be used for environments that rely heavily on indexed views and indexes on computed columns. Generally, the <code>PARAMETERIZATION FORCED</code> option should only be used by experienced database professionals after determining that doing this doesn't adversely affect performance.</li>
<li>Distributed queries that reference more than one database are eligible for forced parameterization as long as the <code>PARAMETERIZATION</code> option is set to <code>FORCED</code> in the database whose context the query is running.</li>
<li>Setting the <code>PARAMETERIZATION</code> option to <code>FORCED</code> flushes all query plans from the plan cache of a database, except those that currently are compiling, recompiling, or running. Plans for queries that are compiling or running during the setting change are parameterized the next time the query is executed.</li>
<li>Setting the <code>PARAMETERIZATION</code> option is an online operation that it requires no database-level exclusive locks.</li>
<li>The current setting of the <code>PARAMETERIZATION</code> option is preserved when reattaching or restoring a database.</li>
</ul>
<p>You can override the behavior of forced parameterization by specifying that simple parameterization be attempted on a single query, and any others that are syntactically equivalent but differ only in their parameter values. Conversely, you can specify that forced parameterization be attempted on only a set of syntactically equivalent queries, even if forced parameterization is disabled in the database. <a href="performance/plan-guides?view=sql-server-ver17" data-linktype="relative-path">Plan guides</a> are used for this purpose.</p>
<div class="NOTE">
<p>Note</p>
<p>When the <code>PARAMETERIZATION</code> option is set to <code>FORCED</code>, the reporting of error messages can differ from when the <code>PARAMETERIZATION</code> option is set to <code>SIMPLE</code>: multiple error messages might be reported under forced parameterization, where fewer messages would be reported under simple parameterization, and the line numbers in which errors occur can be reported incorrectly.</p>
</div>
<h3 id="prepare-sql-statements">Prepare SQL statements</h3>
<p>The SQL Server relational engine introduces full support for preparing Transact-SQL statements before they are executed. If an application has to execute an Transact-SQL statement several times, it can use the database API to do the following:</p>
<ul>
<li>Prepare the statement once. This compiles the Transact-SQL statement into an execution plan.</li>
<li>Execute the precompiled execution plan every time it has to execute the statement. This prevents having to recompile the Transact-SQL statement on each execution after the first time.
Preparing and executing statements is controlled by API functions and methods. It isn't part of the Transact-SQL language. The prepare/execute model of executing Transact-SQL statements is supported by the SQL Server Native Client OLE DB Provider and the SQL Server Native Client ODBC driver. On a prepare request, either the provider or the driver sends the statement to SQL Server with a request to prepare the statement. SQL Server compiles an execution plan and returns a handle for that plan to the provider or driver. On an execute request, either the provider or the driver sends the server a request to execute the plan that is associated with the handle.</li>
</ul>
<p>Prepared statements can't be used to create temporary objects on SQL Server. Prepared statements can't reference system stored procedures that create temporary objects, such as temporary tables. These procedures must be executed directly.</p>
<p>Excess use of the prepare/execute model can degrade performance. If a statement is executed only once, a direct execution requires only one network round-trip to the server. Preparing and executing an Transact-SQL statement executed only one time requires an extra network round-trip; one trip to prepare the statement and one trip to execute it.</p>
<p>Preparing a statement is more effective if parameter markers are used. For example, assume that an application is occasionally asked to retrieve product information from the <code>AdventureWorks</code> sample database. There are two ways the application can do this.</p>
<p>Using the first way, the application can execute a separate query for each product requested:</p>
<pre><code class="lang-sql">SELECT * FROM AdventureWorks2022.Production.Product
WHERE ProductID = 63;
</code></pre>
<p>Using the second way, the application does the following:</p>
<ol>
<li><p>Prepares a statement that contains a parameter marker (?):</p>
<pre><code class="lang-sql">SELECT * FROM AdventureWorks2022.Production.Product
WHERE ProductID = ?;
</code></pre>
</li>
<li><p>Binds a program variable to the parameter marker.</p>
</li>
<li><p>Each time product information is needed, fills the bound variable with the key value and executes the statement.</p>
</li>
</ol>
<p>The second way is more efficient when the statement is executed more than three times.</p>
<p>In SQL Server, the prepare/execute model has no significant performance advantage over direct execution, because of the way SQL Server reuses execution plans. SQL Server has efficient algorithms for matching current Transact-SQL statements with execution plans that are generated for prior executions of the same Transact-SQL statement. If an application executes a Transact-SQL statement with parameter markers multiple times, SQL Server will reuse the execution plan from the first execution for the second and subsequent executions (unless the plan ages from the plan cache). The prepare/execute model still has these benefits:</p>
<ul>
<li>Finding an execution plan by an identifying handle is more efficient than the algorithms used to match an Transact-SQL statement to existing execution plans.</li>
<li>The application can control when the execution plan is created and when it is reused.</li>
<li>The prepare/execute model is portable to other databases, including earlier versions of SQL Server.</li>
</ul>
<h3 id="parameter-sensitivity">Parameter sensitivity</h3>
<p>Parameter sensitivity, also known as "parameter sniffing", refers to a process whereby SQL Server "sniffs" the current parameter values during compilation or recompilation, and passes it along to the Query Optimizer so that they can be used to generate potentially more efficient query execution plans.</p>
<p>Parameter values are sniffed during compilation or recompilation for the following types of batches:</p>
<ul>
<li>Stored procedures</li>
<li>Queries submitted via <code>sp_executesql</code></li>
<li>Prepared queries</li>
</ul>
<p>For more information on troubleshooting parameter sniffing issues, see:</p>
<ul>
<li><a href="/en-us/troubleshoot/sql/performance/troubleshoot-high-cpu-usage-issues#step-5-investigate-and-resolve-parameter-sensitive-issues" data-linktype="absolute-path">Investigate and resolve parameter-sensitive issues</a></li>
<li><a href="#parameters-and-execution-plan-reuse" data-linktype="self-bookmark">Parameters and Execution Plan Reuse</a></li>
<li><a href="performance/parameter-sensitive-plan-optimization?view=sql-server-ver17" data-linktype="relative-path">Parameter Sensitive Plan optimization</a></li>
<li><a href="/en-us/azure/azure-sql/database/identify-query-performance-issues#parameter-sensitivity" data-linktype="absolute-path">Troubleshoot queries with parameter sensitive query execution plan issues in Azure SQL Database</a></li>
<li><a href="/en-us/azure/azure-sql/managed-instance/identify-query-performance-issues#parameter-sensitivity" data-linktype="absolute-path">Troubleshoot queries with parameter sensitive query execution plan issues in Azure SQL Managed Instance</a></li>
</ul>
<p>When a query in SQL Server uses the <code>OPTION (RECOMPILE)</code> hint, the query optimizer turns parameter and local variables into compile-time constants that can be constant folded and reduced to literals. This means that during compilation, the optimizer knows and can use the current runtime values of parameters and local variables as they exist immediately prior to that statement. The OPTION (RECOMPILE) allows the optimizer to generate a more optimal query plan tailored to the specific values and to take advantage of the best underlying indexes at run time. For parameters, this process refers not to the values originally passed to the batch or stored procedure, but to their values at the time of recompilation. These values might have been modified within the procedure before reaching the statement that includes <code>RECOMPILE</code>. This behavior can improve performance for queries with highly variable or skewed input data.</p>
<h3 id="local-variables">Local variables</h3>
<p>When a query uses local variables, SQL Server can't sniff their values at compile time, so it estimates cardinality using available statistics or heuristics. If statistics exist, it typically uses the <strong>All Density</strong> value (also known as <strong>average density</strong>) from the statistical histogram to estimate how many rows match the predicate. However, if no statistics are available for the column, SQL Server falls back on heuristic estimates, such as assuming 10% selectivity for equality predicates, and 30% for inequalities and ranges, which might lead to less accurate execution plans. Here's an example of a query that uses a local variable.</p>
<pre><code class="lang-sql">DECLARE @ProductId INT = 100;
SELECT * FROM Products WHERE ProductId = @ProductId;
</code></pre>
<p>In this case, SQL Server doesn't use the value 100 to optimize the query. It uses a general estimate.</p>
<h2 id="parallel-query-processing">Parallel query processing</h2>
<p>SQL Server provides parallel queries to optimize query execution and index operations for computers that have more than one microprocessor (CPU). Because SQL Server can perform a query or index operation in parallel by using several operating system worker threads, the operation can be completed quickly and efficiently.</p>
<p>During query optimization, SQL Server looks for queries or index operations that might benefit from parallel execution. For these queries, SQL Server inserts exchange operators into the query execution plan to prepare the query for parallel execution. An exchange operator is an operator in a query execution plan that provides process management, data redistribution, and flow control. The exchange operator includes the <code>Distribute Streams</code>, <code>Repartition Streams</code>, and <code>Gather Streams</code> logical operators as subtypes, one or more of which can appear in the Showplan output of a query plan for a parallel query.</p>
<div class="IMPORTANT">
<p>Important</p>
<p>Certain constructs inhibit SQL Server's ability to use parallelism on the entire execution plan, or parts or the execution plan.</p>
</div>
<p>Constructs that inhibit parallelism include:</p>
<ul>
<li><p><strong>Scalar UDFs</strong><br>
For more information on scalar user-defined functions, see <a href="user-defined-functions/create-user-defined-functions-database-engine?view=sql-server-ver17#Scalar" data-linktype="relative-path">Create User-defined Functions</a>. Starting with SQL Server 2019 (15.x), the SQL Server Database Engine has the ability to inline these functions, and unlock use of parallelism during query processing. For more information on scalar UDF inlining, see <a href="performance/intelligent-query-processing-details?view=sql-server-ver17#scalar-udf-inlining" data-linktype="relative-path">Intelligent query processing in SQL databases</a>.</p>
</li>
<li><p><strong>Remote Query</strong><br>
For more information on Remote Query, see <a href="showplan-logical-and-physical-operators-reference?view=sql-server-ver17" data-linktype="relative-path">Showplan Logical and Physical Operators Reference</a>.</p>
</li>
<li><p><strong>Dynamic cursors</strong><br>
For more information on cursors, see <a href="../t-sql/language-elements/declare-cursor-transact-sql?view=sql-server-ver17" data-linktype="relative-path">DECLARE CURSOR</a>.</p>
</li>
<li><p><strong>Recursive queries</strong><br>
For more information on recursion, see <a href="../t-sql/queries/with-common-table-expression-transact-sql?view=sql-server-ver17#guidelines-for-defining-and-using-recursive-common-table-expressions" data-linktype="relative-path">Guidelines for Defining and Using Recursive Common Table Expressions</a> and <a href="/en-us/previous-versions/sql/legacy/aa175801(v=sql.80)" data-linktype="absolute-path">Recursion in T-SQL</a>.</p>
</li>
<li><p><strong>Multi-statement table-valued functions (MSTVFs)</strong><br>
For more information on MSTVFs, see <a href="user-defined-functions/create-user-defined-functions-database-engine?view=sql-server-ver17#TVF" data-linktype="relative-path">Create User-defined Functions (Database Engine)</a>.</p>
</li>
<li><p><strong>TOP keyword</strong><br>
For more information, see <a href="../t-sql/queries/top-transact-sql?view=sql-server-ver17" data-linktype="relative-path">TOP (Transact-SQL)</a>.</p>
</li>
</ul>
<p>A query execution plan can contain the <strong>NonParallelPlanReason</strong> attribute in the <strong>QueryPlan</strong> element, which describes why parallelism wasn't used. Values for this attribute include:</p>
<table>
<thead>
<tr>
<th>NonParallelPlanReason Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>MaxDOPSetToOne</td>
<td>Maximum degree of parallelism set to 1.</td>
</tr>
<tr>
<td>EstimatedDOPIsOne</td>
<td>Estimated degree of parallelism is 1.</td>
</tr>
<tr>
<td>NoParallelWithRemoteQuery</td>
<td>Parallelism isn't supported for remote queries.</td>
</tr>
<tr>
<td>NoParallelDynamicCursor</td>
<td>Parallel plans not supported for dynamic cursors.</td>
</tr>
<tr>
<td>NoParallelFastForwardCursor</td>
<td>Parallel plans not supported for fast forward cursors.</td>
</tr>
<tr>
<td>NoParallelCursorFetchByBookmark</td>
<td>Parallel plans not supported for cursors that fetch by bookmark.</td>
</tr>
<tr>
<td>NoParallelCreateIndexInNonEnterpriseEdition</td>
<td>Parallel index creation not supported for non-Enterprise edition.</td>
</tr>
<tr>
<td>NoParallelPlansInDesktopOrExpressEdition</td>
<td>Parallel plans not supported for Desktop and Express edition.</td>
</tr>
<tr>
<td>NonParallelizableIntrinsicFunction</td>
<td>Query is referencing a non-parallelizable intrinsic function.</td>
</tr>
<tr>
<td>CLRUserDefinedFunctionRequiresDataAccess</td>
<td>Parallelism not supported for a CLR UDF that requires data access.</td>
</tr>
<tr>
<td>TSQLUserDefinedFunctionsNotParallelizable</td>
<td>Query is referencing a T-SQL User Defined Function that wasn't parallelizable.</td>
</tr>
<tr>
<td>TableVariableTransactionsDoNotSupportParallelNestedTransaction</td>
<td>Table variable transactions don't support parallel nested transactions.</td>
</tr>
<tr>
<td>DMLQueryReturnsOutputToClient</td>
<td>DML query returns output to client and isn't parallelizable.</td>
</tr>
<tr>
<td>MixedSerialAndParallelOnlineIndexBuildNotSupported</td>
<td>Unsupported mix of serial and parallel plans for a single online index build.</td>
</tr>
<tr>
<td>CouldNotGenerateValidParallelPlan</td>
<td>Verifying parallel plan failed, failing back to serial.</td>
</tr>
<tr>
<td>NoParallelForMemoryOptimizedTables</td>
<td>Parallelism not supported for referenced In-Memory OLTP tables.</td>
</tr>
<tr>
<td>NoParallelForDmlOnMemoryOptimizedTable</td>
<td>Parallelism not supported for DML on an In-Memory OLTP table.</td>
</tr>
<tr>
<td>NoParallelForNativelyCompiledModule</td>
<td>Parallelism not supported for referenced natively compiled modules.</td>
</tr>
<tr>
<td>NoRangesResumableCreate</td>
<td>Range generation failed for a resumable create operation.</td>
</tr>
</tbody>
</table>
<p>After exchange operators are inserted, the result is a parallel-query execution plan. A parallel-query execution plan can use more than one worker thread. A serial execution plan, used by a non-parallel (serial) query, uses only one worker thread for its execution. The actual number of worker threads used by a parallel query is determined at query plan execution initialization and is determined by the complexity of the plan and the degree of parallelism.</p>
<p>Degree of parallelism (DOP) determines the maximum number of CPUs that are being used; it doesn't mean the number of worker threads that are being used. The DOP limit is set per <a href="system-dynamic-management-views/sys-dm-os-tasks-transact-sql?view=sql-server-ver17" data-linktype="relative-path">task</a>. It isn't a per <a href="system-dynamic-management-views/sys-dm-exec-requests-transact-sql?view=sql-server-ver17" data-linktype="relative-path">request</a> or per query limit. This means that during a parallel query execution, a single request can spawn multiple tasks that are assigned to a <a href="system-dynamic-management-views/sys-dm-os-tasks-transact-sql?view=sql-server-ver17" data-linktype="relative-path">scheduler</a>. More processors than specified by the MAXDOP might be used concurrently at any given point of query execution, when different tasks are executed concurrently. For more information, see the <a href="thread-and-task-architecture-guide?view=sql-server-ver17" data-linktype="relative-path">Thread and Task Architecture Guide</a>.</p>
<p>The SQL Server Query Optimizer doesn't use a parallel execution plan for a query if any one of the following conditions is true:</p>
<ul>
<li>The serial execution plan is trivial, or does not exceed the cost threshold for parallelism setting.</li>
<li>The serial execution plan has a lower total estimated subtree cost than any parallel execution plan explored by the optimizer.</li>
<li>The query contains scalar or relational operators that can't be run in parallel. Certain operators can cause a section of the query plan to run in serial mode, or the whole plan to run in serial mode.</li>
</ul>
<div class="NOTE">
<p>Note</p>
<p>The total estimated subtree cost of a parallel plan can be lower than the cost threshold for parallelism setting. This indicates that the total estimated subtree cost of the serial plan exceeded it, and the query plan with the lower total estimated subtree cost was chosen.</p>
</div>
<h3 id="degree-of-parallelism-dop">Degree of parallelism (DOP)</h3>
<p><a id="DOP"></a></p>
<p>SQL Server automatically detects the best degree of parallelism for each instance of a parallel query execution or index data definition language (DDL) operation. It does this based on the following criteria:</p>
<ol>
<li><p>Whether SQL Server is <strong>running on a computer that has more than one microprocessor or CPU</strong>, such as a symmetric multiprocessing computer (SMP). Only computers that have more than one CPU can use parallel queries.</p>
</li>
<li><p>Whether <strong>sufficient worker threads are available</strong>. Each query or index operation requires a certain number of worker threads to execute. Executing a parallel plan requires more worker threads than a serial plan, and the number of required worker threads increases with the degree of parallelism. When the worker thread requirement of the parallel plan for a specific degree of parallelism can't be satisfied, the SQL Server Database Engine decreases the degree of parallelism automatically or completely abandons the parallel plan in the specified workload context. It then executes the serial plan (one worker thread).</p>
</li>
<li><p>The <strong>type of query or index operation executed</strong>. Index operations that create or rebuild an index, or drop a clustered index and queries that use CPU cycles heavily are the best candidates for a parallel plan. For example, joins of large tables, large aggregations, and sorting of large result sets are good candidates. Simple queries, frequently found in transaction processing applications, find the additional coordination required to execute a query in parallel outweigh the potential performance boost. To distinguish between queries that benefit from parallelism and those that don't benefit, the SQL Server Database Engine compares the estimated cost of executing the query or index operation with the <a href="../database-engine/configure-windows/configure-the-cost-threshold-for-parallelism-server-configuration-option?view=sql-server-ver17" data-linktype="relative-path">cost threshold for parallelism</a> value. Users can change the default value of 5 using <a href="system-stored-procedures/sp-configure-transact-sql?view=sql-server-ver17" data-linktype="relative-path">sp_configure</a> if proper testing found that a different value is better suited for the running workload.</p>
</li>
<li><p>Whether there are a <strong>sufficient number of rows to process</strong>. If the Query Optimizer determines that the number of rows is too low, it doesn't introduce exchange operators to distribute the rows. Thus, the operators are executed serially. Executing the operators in a serial plan avoids scenarios when the startup, distribution, and coordination costs exceed the gains achieved by parallel operator execution.</p>
</li>
<li><p>Whether <strong>current distribution statistics are available</strong>. If the highest degree of parallelism isn't possible, lower degrees are considered before the parallel plan is abandoned. For example, when you create a clustered index on a view, distribution statistics can't be evaluated, because the clustered index doesn't yet exist. In this case, the SQL Server Database Engine can't provide the highest degree of parallelism for the index operation. However, some operators, such as sorting and scanning, can still benefit from parallel execution.</p>
</li>
</ol>
<div class="NOTE">
<p>Note</p>
<p>Parallel index operations are only available in SQL Server Enterprise, Developer, and Evaluation editions.</p>
</div>
<p>At execution time, the SQL Server Database Engine determines whether the current system workload and configuration information previously described allow for parallel execution. If parallel execution is warranted, the SQL Server Database Engine determines the optimal number of worker threads and spreads the execution of the parallel plan across those worker threads. When a query or index operation starts executing on multiple worker threads for parallel execution, the same number of worker threads is used until the operation is completed. The SQL Server Database Engine re-examines the optimal number of worker thread decisions every time an execution plan is retrieved from the plan cache. For example, one execution of a query can result in the use of a serial plan, a later execution of the same query can result in a parallel plan using three worker threads, and a third execution can result in a parallel plan using four worker threads.</p>
<p>The update and delete operators in a parallel query execution plan are executed serially, but the <code>WHERE</code> clause of an <code>UPDATE</code> or a <code>DELETE</code> statement might be executed in parallel. The actual data changes are then serially applied to the database.</p>
<p>Up to SQL Server 2012 (11.x), the insert operator is also executed serially. However, the SELECT part of an INSERT statement might be executed in parallel. The actual data changes are then serially applied to the database.</p>
<p>Starting with SQL Server 2014 (12.x) and database compatibility level 110, the <code>SELECT ... INTO</code> statement can be executed in parallel. Other forms of insert operators work the same way as described for SQL Server 2012 (11.x).</p>
<p>Starting with SQL Server 2016 (13.x) and database compatibility level 130, the <code>INSERT ... SELECT</code> statement can be executed in parallel when inserting into heaps or clustered columnstore indexes (CCI), and using the TABLOCK hint. Inserts into local temporary tables (identified by the # prefix) and global temporary tables (identified by ## prefixes) are also enabled for parallelism using the TABLOCK hint. For more information, see <a href="../t-sql/statements/insert-transact-sql?view=sql-server-ver17#best-practices" data-linktype="relative-path">INSERT (Transact-SQL)</a>.</p>
<p>Static and keyset-driven cursors can be populated by parallel execution plans. However, the behavior of dynamic cursors can be provided only by serial execution. The Query Optimizer always generates a serial execution plan for a query that is part of a dynamic cursor.</p>
<h4 id="overriding-degrees-of-parallelism"> Override degrees of parallelism</h4>
<p>The degree of parallelism sets the number of processors to use in parallel plan execution. This configuration can be set at various levels:</p>
<ol>
<li><p>Server level, using the <strong>max degree of parallelism (MAXDOP)</strong> <a href="../database-engine/configure-windows/configure-the-max-degree-of-parallelism-server-configuration-option?view=sql-server-ver17" data-linktype="relative-path">server configuration option</a>.<br> <strong>Applies to:</strong> SQL Server</p>
<div class="NOTE">
<p>Note</p>
<p>SQL Server 2019 (15.x) introduces automatic recommendations for setting the MAXDOP server configuration option during the installation process. The setup user interface allows you to either accept the recommended settings or enter your own value. For more information, see <a href="../sql-server/install/instance-configuration?view=sql-server-ver17#maxdop" data-linktype="relative-path">Database Engine Configuration - MaxDOP page</a>.</p>
</div>
</li>
<li><p>Workload level, using the <strong>MAX_DOP</strong> <a href="../t-sql/statements/create-workload-group-transact-sql?view=sql-server-ver17" data-linktype="relative-path">Resource Governor workload group configuration option</a>.<br> <strong>Applies to:</strong> SQL Server</p>
</li>
<li><p>Database level, using the <strong>MAXDOP</strong> <a href="../t-sql/statements/alter-database-scoped-configuration-transact-sql?view=sql-server-ver17" data-linktype="relative-path">database scoped configuration</a>.<br> <strong>Applies to:</strong> SQL Server and Azure SQL Database</p>
</li>
<li><p>Query or index statement level, using the <strong>MAXDOP</strong> <a href="../t-sql/queries/hints-transact-sql-query?view=sql-server-ver17" data-linktype="relative-path">query hint</a> or <strong>MAXDOP</strong> index option. For example, you can use the MAXDOP option to control, by increasing or reducing, the number of processors dedicated to an online index operation. In this way, you can balance the resources used by an index operation with those of the concurrent users.<br> <strong>Applies to:</strong> SQL Server and Azure SQL Database</p>
</li>
</ol>
<p>Setting the max degree of parallelism option to 0 (default) enables SQL Server to use all available processors up to a maximum of 64 processors in a parallel plan execution. Although SQL Server sets a runtime target of 64 logical processors when MAXDOP option is set to 0, a different value can be manually set if needed. Setting MAXDOP to 0 for queries and indexes allows SQL Server to use all available processors up to a maximum of 64 processors for the given queries or indexes in a parallel plan execution. MAXDOP isn't an enforced value for all parallel queries, but rather a tentative target for all queries eligible for parallelism. This means that if not enough worker threads are available at runtime, a query might execute with a lower degree of parallelism than the MAXDOP server configuration option.</p>
<div class="TIP">
<p>Tip</p>
<p>For more information, see <a href="../database-engine/configure-windows/configure-the-max-degree-of-parallelism-server-configuration-option?view=sql-server-ver17#recommendations" data-linktype="relative-path">MAXDOP recommendations</a> for guidelines on configuring MAXDOP at the server, database, query, or hint level.</p>
</div>
<h3 id="parallel-query-example">Parallel query example</h3>
<p>The following query counts the number of orders placed in a specific quarter, starting on April 1, 2000, and in which at least one line item of the order was received by the customer later than the committed date. This query lists the count of such orders grouped by each order priority and sorted in ascending priority order.</p>
<p>This example uses theoretical table and column names.</p>
<pre><code class="lang-sql">SELECT o_orderpriority, COUNT(*) AS Order_Count
FROM orders
WHERE o_orderdate &gt;= '2000/04/01'
   AND o_orderdate &lt; DATEADD (mm, 3, '2000/04/01')
   AND EXISTS
         (
          SELECT *
            FROM    lineitem
            WHERE l_orderkey = o_orderkey
               AND l_commitdate &lt; l_receiptdate
         )
   GROUP BY o_orderpriority
   ORDER BY o_orderpriority
</code></pre>
<p>Assume the following indexes are defined on the <code>lineitem</code> and <code>orders</code> tables:</p>
<pre><code class="lang-sql">CREATE INDEX l_order_dates_idx
   ON lineitem
      (l_orderkey, l_receiptdate, l_commitdate, l_shipdate)

CREATE UNIQUE INDEX o_datkeyopr_idx
   ON ORDERS
      (o_orderdate, o_orderkey, o_custkey, o_orderpriority)
</code></pre>
<p>Here is one possible parallel plan generated for the query previously shown:</p>
<pre><code class="lang-output">|--Stream Aggregate(GROUP BY:([ORDERS].[o_orderpriority])
                  DEFINE:([Expr1005]=COUNT(*)))
    |--Parallelism(Gather Streams, ORDER BY:
                  ([ORDERS].[o_orderpriority] ASC))
         |--Stream Aggregate(GROUP BY:
                  ([ORDERS].[o_orderpriority])
                  DEFINE:([Expr1005]=Count(*)))
              |--Sort(ORDER BY:([ORDERS].[o_orderpriority] ASC))
                   |--Merge Join(Left Semi Join, MERGE:
                  ([ORDERS].[o_orderkey])=
                        ([LINEITEM].[l_orderkey]),
                  RESIDUAL:([ORDERS].[o_orderkey]=
                        [LINEITEM].[l_orderkey]))
                        |--Sort(ORDER BY:([ORDERS].[o_orderkey] ASC))
                        |    |--Parallelism(Repartition Streams,
                           PARTITION COLUMNS:
                           ([ORDERS].[o_orderkey]))
                        |         |--Index Seek(OBJECT:
                     ([tpcd1G].[dbo].[ORDERS].[O_DATKEYOPR_IDX]),
                     SEEK:([ORDERS].[o_orderdate] &gt;=
                           Apr  1 2000 12:00AM AND
                           [ORDERS].[o_orderdate] &lt;
                           Jul  1 2000 12:00AM) ORDERED)
                        |--Parallelism(Repartition Streams,
                     PARTITION COLUMNS:
                     ([LINEITEM].[l_orderkey]),
                     ORDER BY:([LINEITEM].[l_orderkey] ASC))
                             |--Filter(WHERE:
                           ([LINEITEM].[l_commitdate]&lt;
                           [LINEITEM].[l_receiptdate]))
                                  |--Index Scan(OBJECT:
         ([tpcd1G].[dbo].[LINEITEM].[L_ORDER_DATES_IDX]), ORDERED)
</code></pre>
<p>The illustration below shows a query plan executed with a degree of parallelism equal to 4 and involving a two-table join.</p>
<p><span class="mx-imgBorder">
<img src="media/query-processing-architecture-guide/parallel-plan.gif?view=sql-server-ver17" alt="Diagram of a parallel plan." data-linktype="relative-path">
</span>
</p>
<p>The parallel plan contains three parallelism operators. Both the Index Seek operator of the <code>o_datkey_ptr</code> index and the Index Scan operator of the <code>l_order_dates_idx</code> index are performed in parallel. This produces several exclusive streams. This can be determined from the nearest Parallelism operators above the Index Scan and Index Seek operators, respectively. Both are repartitioning the type of exchange. That is, they are just reshuffling data among the streams and producing the same number of streams on their output as they have on their input. This number of streams is equal to the degree of parallelism.</p>
<p>The parallelism operator above the <code>l_order_dates_idx</code> Index Scan operator is repartitioning its input streams using the value of <code>L_ORDERKEY</code> as a key. In this way, the same values of <code>L_ORDERKEY</code> end up in the same output stream. At the same time, output streams maintain the order on the <code>L_ORDERKEY</code> column to meet the input requirement of the Merge Join operator.</p>
<p>The parallelism operator above the Index Seek operator is repartitioning its input streams using the value of <code>O_ORDERKEY</code>. Because its input isn't sorted on the <code>O_ORDERKEY</code> column values and this is the join column in the <code>Merge Join</code> operator, the Sort operator between the parallelism and Merge Join operators make sure that the input is sorted for the <code>Merge Join</code> operator on the join columns. The <code>Sort</code> operator, like the Merge Join operator, is performed in parallel.</p>
<p>The topmost parallelism operator gathers results from several streams into a single stream. Partial aggregations performed by the Stream Aggregate operator below the parallelism operator are then accumulated into a single <code>SUM</code> value for each different value of the <code>O_ORDERPRIORITY</code> in the Stream Aggregate operator above the parallelism operator. Because this plan has two exchange segments, with degree of parallelism equal to 4, it uses eight worker threads.</p>
<p>For more information on the operators used in this example, see the <a href="showplan-logical-and-physical-operators-reference?view=sql-server-ver17" data-linktype="relative-path">Showplan Logical and Physical Operators Reference</a>.</p>
<h3 id="parallel-index-operations">Parallel index operations</h3>
<p>The query plans built for the index operations that create or rebuild an index, or drop a clustered index, allow for parallel, multi-worker threaded operations on computers that have multiple microprocessors.</p>
<div class="NOTE">
<p>Note</p>
<p>Parallel index operations are only available in Enterprise Edition, starting with SQL Server 2008 (10.0.x).</p>
</div>
<p>SQL Server uses the same algorithms to determine the degree of parallelism (the total number of separate worker threads to run) for index operations as it does for other queries. The maximum degree of parallelism for an index operation is subject to the <a href="../database-engine/configure-windows/configure-the-max-degree-of-parallelism-server-configuration-option?view=sql-server-ver17" data-linktype="relative-path">max degree of parallelism</a> server configuration option. You can override the max degree of parallelism value for individual index operations by setting the MAXDOP index option in the CREATE INDEX, ALTER INDEX, DROP INDEX, and ALTER TABLE statements.</p>
<p>When the SQL Server Database Engine builds an index execution plan, the number of parallel operations is set to the lowest value from among the following:</p>
<ul>
<li>The number of microprocessors, or CPUs in the computer.</li>
<li>The number specified in the max degree of parallelism server configuration option.</li>
<li>The number of CPUs not already over a threshold of work performed for SQL Server worker threads.</li>
</ul>
<p>For example, on a computer that has eight CPUs, but where max degree of parallelism is set to 6, no more than six parallel worker threads are generated for an index operation. If five of the CPUs in the computer exceed the threshold of SQL Server work when an index execution plan is built, the execution plan specifies only three parallel worker threads.</p>
<p>The main phases of a parallel index operation include the following:</p>
<ul>
<li>A coordinating worker thread quickly and randomly scans the table to estimate the distribution of the index keys. The coordinating worker thread establishes the key boundaries that will create a number of key ranges equal to the degree of parallel operations, where each key range is estimated to cover similar numbers of rows. For example, if there are four million rows in the table and the degree of parallelism is 4, the coordinating worker thread will determine the key values that delimit four sets of rows with 1 million rows in each set. If enough key ranges can't be established to use all CPUs, the degree of parallelism is reduced accordingly.</li>
<li>The coordinating worker thread dispatches a number of worker threads equal to the degree of parallel operations and waits for these worker threads to complete their work. Each worker thread scans the base table using a filter that retrieves only rows with key values within the range assigned to the worker thread. Each worker thread builds an index structure for the rows in its key range. In the case of a partitioned index, each worker thread builds a specified number of partitions. Partitions aren't shared among worker threads.</li>
<li>After all the parallel worker threads have completed, the coordinating worker thread connects the index subunits into a single index. This phase applies only to offline index operations.</li>
</ul>
<p>Individual <code>CREATE TABLE</code> or <code>ALTER TABLE</code> statements can have multiple constraints that require that an index be created. These multiple index creation operations are performed in series, although each individual index creation operation might be a parallel operation on a computer that has multiple CPUs.</p>
<h2 id="distributed-query-architecture">Distributed query architecture</h2>
<p>Microsoft SQL Server supports two methods for referencing heterogeneous OLE DB data sources in Transact-SQL statements:</p>
<ul>
<li><p>Linked server names<br>
The system stored procedures <code>sp_addlinkedserver</code> and <code>sp_addlinkedsrvlogin</code> are used to give a server name to an OLE DB data source. Objects in these linked servers can be referenced in Transact-SQL statements using four-part names. For example, if a linked server name of <code>DeptSQLSrvr</code> is defined against another instance of SQL Server, the following statement references a table on that server:</p>
<pre><code class="lang-sql">SELECT JobTitle, HireDate
FROM DeptSQLSrvr.AdventureWorks2022.HumanResources.Employee;
</code></pre>
<p>The linked server name can also be specified in an <code>OPENQUERY</code> statement to open a rowset from the OLE DB data source. This rowset can then be referenced like a table in Transact-SQL statements.</p>
</li>
<li><p>Ad hoc connector names<br>
For infrequent references to a data source, the <code>OPENROWSET</code> or <code>OPENDATASOURCE</code> functions are specified with the information needed to connect to the linked server. The rowset can then be referenced the same way a table is referenced in Transact-SQL statements:</p>
<pre><code class="lang-sql">SELECT *
FROM OPENROWSET('Microsoft.Jet.OLEDB.4.0',
      'c:\MSOffice\Access\Samples\Northwind.mdb';'Admin';'';
      Employees);
</code></pre>
</li>
</ul>
<p>SQL Server uses OLE DB to communicate between the relational engine and the storage engine. The relational engine breaks down each Transact-SQL statement into a series of operations on simple OLE DB rowsets opened by the storage engine from the base tables. This means the relational engine can also open simple OLE DB rowsets on any OLE DB data source.</p>
<p><span class="mx-imgBorder">
<img src="media/query-processing-architecture-guide/oledb-storage.gif?view=sql-server-ver17" alt="Diagram of OLE DB storage." data-linktype="relative-path">
</span>
</p>
<p>The relational engine uses the OLE DB application programming interface (API) to open the rowsets on linked servers, fetch the rows, and manage transactions.</p>
<p>For each OLE DB data source accessed as a linked server, an OLE DB provider must be present on the server running SQL Server. The set of Transact-SQL operations that can be used against a specific OLE DB data source depends on the capabilities of the OLE DB provider.</p>
<p>For each instance of SQL Server, members of the <code>sysadmin</code> fixed server role can enable or disable the use of ad hoc connector names for an OLE DB provider using the SQL Server <code>DisallowAdhocAccess</code> property. When ad hoc access is enabled, any user logged on to that instance can execute Transact-SQL statements containing ad hoc connector names, referencing any data source on the network that can be accessed using that OLE DB provider. To control access to data sources, members of the <code>sysadmin</code> role can disable ad hoc access for that OLE DB provider, thereby limiting users to only those data sources referenced by linked server names defined by the administrators. By default, ad hoc access is enabled for the SQL Server OLE DB provider, and disabled for all other OLE DB providers.</p>
<p>Distributed queries can allow users to access another data source (for example, files, non-relational data sources such as Active Directory, and so on) using the security context of the Microsoft Windows account under which the SQL Server service is running. SQL Server impersonates the login appropriately for Windows logins; however, that isn't possible for SQL Server logins. This can potentially allow a distributed query user to access another data source for which they don't have permissions, but the account under which the SQL Server service is running does have permissions. Use <code>sp_addlinkedsrvlogin</code> to define the specific logins that are authorized to access the corresponding linked server. This control isn't available for ad hoc names, so use caution in enabling an OLE DB provider for ad hoc access.</p>
<p>When possible, SQL Server pushes relational operations such as joins, restrictions, projections, sorts, and group by operations to the OLE DB data source. SQL Server doesn't default to scanning the base table into SQL Server and performing the relational operations itself. SQL Server queries the OLE DB provider to determine the level of SQL grammar it supports, and, based on that information, pushes as many relational operations as possible to the provider.</p>
<p>SQL Server specifies a mechanism for an OLE DB provider to return statistics indicating how key values are distributed within the OLE DB data source. This lets the SQL Server Query Optimizer better analyze the pattern of data in the data source against the requirements of each Transact-SQL statement, increasing the ability of the Query Optimizer to generate optimal execution plans.</p>
<h2 id="query-processing-enhancements-on-partitioned-tables-and-indexes">Query processing enhancements on partitioned tables and indexes</h2>
<p>SQL Server 2008 (10.0.x) improved query processing performance on partitioned tables for many parallel plans, changes the way parallel and serial plans are represented, and enhanced the partitioning information provided in both compile-time and run-time execution plans. This article describes these improvements, provides guidance on how to interpret the query execution plans of partitioned tables and indexes, and provides best practices for improving query performance on partitioned objects.</p>
<div class="NOTE">
<p>Note</p>
<p>Until SQL Server 2014 (12.x), partitioned tables and indexes are supported only in the SQL Server Enterprise, Developer, and Evaluation editions.
Starting with SQL Server 2016 (13.x) SP1, partitioned tables and indexes are also supported in SQL Server Standard edition.</p>
</div>
<h3 id="new-partition-aware-seek-operation">New partition-aware seek operation</h3>
<p>In SQL Server, the internal representation of a partitioned table is changed so that the table appears to the query processor to be a multicolumn index with <code>PartitionID</code> as the leading column. <code>PartitionID</code> is a hidden computed column used internally to represent the <code>ID</code> of the partition containing a specific row. For example, assume the table T, defined as <code>T(a, b, c)</code>, is partitioned on column a, and has a clustered index on column b. In SQL Server, this partitioned table is treated internally as a nonpartitioned table with the schema <code>T(PartitionID, a, b, c)</code> and a clustered index on the composite key <code>(PartitionID, b)</code>. This allows the Query Optimizer to perform seek operations based on <code>PartitionID</code> on any partitioned table or index.</p>
<p>Partition elimination is now done in this seek operation.</p>
<p>In addition, the Query Optimizer is extended so that a seek or scan operation with one condition can be done on <code>PartitionID</code> (as the logical leading column) and possibly other index key columns, and then a second-level seek, with a different condition, can be done on one or more additional columns, for each distinct value that meets the qualification for the first-level seek operation. That is, this operation, called a skip scan, allows the Query Optimizer to perform a seek or scan operation based on one condition to determine the partitions to be accessed and a second-level index seek operation within that operator to return rows from these partitions that meet a different condition. For example, consider the following query.</p>
<pre><code class="lang-sql">SELECT * FROM T WHERE a &lt; 10 and b = 2;
</code></pre>
<p>For this example, assume that table T, defined as <code>T(a, b, c)</code>, is partitioned on column a, and has a clustered index on column b. The partition boundaries for table T are defined by the following partition function:</p>
<pre><code class="lang-sql">CREATE PARTITION FUNCTION myRangePF1 (int) AS RANGE LEFT FOR VALUES (3, 7, 10);
</code></pre>
<p>To solve the query, the query processor performs a first-level seek operation to find every partition that contains rows that meet the condition <code>T.a &lt; 10</code>. This identifies the partitions to be accessed. Within each partition identified, the processor then performs a second-level seek into the clustered index on column b to find the rows that meet the condition <code>T.b = 2</code> and <code>T.a &lt; 10</code>.</p>
<p>The following illustration is a logical representation of the skip scan operation. It shows table <code>T</code> with data in columns <code>a</code> and <code>b</code>. The partitions are numbered 1 through 4 with the partition boundaries shown by dashed vertical lines. A first-level seek operation to the partitions (not shown in the illustration) has determined that partitions 1, 2, and 3 meet the seek condition implied by the partitioning defined for the table and the predicate on column <code>a</code>. That is, <code>T.a &lt; 10</code>. The path traversed by the second-level seek portion of the skip scan operation is illustrated by the curved line. Essentially, the skip scan operation seeks into each of these partitions for rows that meet the condition <code>b = 2</code>. The total cost of the skip scan operation is the same as that of three separate index seeks.</p>
<p><span class="mx-imgBorder">
<img src="media/query-processing-architecture-guide/skip-scan.gif?view=sql-server-ver17" alt="Diagram showing how skip scan works." data-linktype="relative-path">
</span>
</p>
<h3 id="display-partitioning-information-in-query-execution-plans">Display partitioning information in query execution plans</h3>
<p>The execution plans of queries on partitioned tables and indexes can be examined by using the Transact-SQL <code>SET</code> statements <code>SET SHOWPLAN_XML</code> or <code>SET STATISTICS XML</code>, or by using the graphical execution plan output in SQL Server Management Studio. For example, you can display the compile-time execution plan by selecting <em>Display Estimated Execution Plan</em> on the Query Editor toolbar and the run-time plan by selecting <em>Include Actual Execution Plan</em>.</p>
<p>Using these tools, you can ascertain the following information:</p>
<ul>
<li>The operations such as <code>scans</code>, <code>seeks</code>, <code>inserts</code>, <code>updates</code>, <code>merges</code>, and <code>deletes</code> that access partitioned tables or indexes.</li>
<li>The partitions accessed by the query. For example, the total count of partitions accessed and the ranges of contiguous partitions that are accessed are available in run-time execution plans.</li>
<li>When the skip scan operation is used in a seek or scan operation to retrieve data from one or more partitions.</li>
</ul>
<h4 id="partition-information-enhancements">Partition information enhancements</h4>
<p>SQL Server provides enhanced partitioning information for both compile-time and run-time execution plans. Execution plans now provide the following information:</p>
<ul>
<li>An optional <code>Partitioned</code> attribute that indicates that an operator, such as a <code>seek</code>, <code>scan</code>, <code>insert</code>, <code>update</code>, <code>merge</code>, or <code>delete</code>, is performed on a partitioned table.</li>
<li>A new <code>SeekPredicateNew</code> element with a <code>SeekKeys</code> subelement that includes <code>PartitionID</code> as the leading index key column and filter conditions that specify range seeks on <code>PartitionID</code>. The presence of two <code>SeekKeys</code> subelements indicates that a skip scan operation on <code>PartitionID</code> is used.</li>
<li>Summary information that provides a total count of the partitions accessed. This information is available only in run-time plans.</li>
</ul>
<p>To demonstrate how this information is displayed in both the graphical execution plan output and the XML Showplan output, consider the following query on the partitioned table <code>fact_sales</code>. This query updates data in two partitions.</p>
<pre><code class="lang-sql">UPDATE fact_sales
SET quantity = quantity - 2
WHERE date_id BETWEEN 20080802 AND 20080902;
</code></pre>
<p>The following illustration shows the properties of the <code>Clustered Index Seek</code> operator in the runtime execution plan for this query. To view the definition of the <code>fact_sales</code> table and the partition definition, see "Example" in this article.</p>
<p><span class="mx-imgBorder">
<img src="media/query-processing-architecture-guide/clustered-index-seek.gif?view=sql-server-ver17" alt="Diagram of a clustered index seek." data-linktype="relative-path">
</span>
</p>
<h4 id="partitioned-attribute">Partitioned attribute</h4>
<p>When an operator such as an Index Seek is executed on a partitioned table or index, the <code>Partitioned</code> attribute appears in the compile-time and run-time plan, and is set to <code>True</code> (1). The attribute doesn't display when it is set to <code>False</code> (0).</p>
<p>The <code>Partitioned</code> attribute can appear in the following physical and logical operators:</p>
<ul>
<li>Table Scan</li>
<li>Index Scan</li>
<li>Index Seek</li>
<li>Insert</li>
<li>Update</li>
<li>Delete</li>
<li>Merge</li>
</ul>
<p>As shown in the previous illustration, this attribute is displayed in the properties of the operator in which it is defined. In the XML Showplan output, this attribute appears as <code>Partitioned="1"</code> in the <code>RelOp</code> node of the operator in which it is defined.</p>
<h4 id="new-seek-predicate">New seek predicate</h4>
<p>In XML Showplan output, the <code>SeekPredicateNew</code> element appears in the operator in which it is defined. It can contain up to two occurrences of the <code>SeekKeys</code> subelement. The first <code>SeekKeys</code> item specifies the first-level seek operation at the partition ID level of the logical index. That is, this seek determines the partitions that must be accessed to satisfy the conditions of the query. The second <code>SeekKeys</code> item specifies the second-level seek portion of the skip scan operation that occurs within each partition identified in the first-level seek.</p>
<h4 id="partition-summary-information">Partition summary information</h4>
<p>In run-time execution plans, partition summary information provides a count of the partitions accessed and the identity of the actual partitions accessed. You can use this information to verify that the correct partitions are accessed in the query and that all other partitions are eliminated from consideration.</p>
<p>The following information is provided: <code>Actual Partition Count</code>, and <code>Partitions Accessed</code>.</p>
<p><code>Actual Partition Count</code> is the total number of partitions accessed by the query.</p>
<p><code>Partitions Accessed</code>, in XML Showplan output, is the partition summary information that appears in the new <code>RuntimePartitionSummary</code> element in <code>RelOp</code> node of the operator in which it is defined. The following example shows the contents of the <code>RuntimePartitionSummary</code> element, indicating that two total partitions are accessed (partitions 2 and 3).</p>
<pre><code class="lang-xml">&lt;RunTimePartitionSummary&gt;
    &lt;PartitionsAccessed PartitionCount="2" &gt;
        &lt;PartitionRange Start="2" End="3" /&gt;
    &lt;/PartitionsAccessed&gt;
&lt;/RunTimePartitionSummary&gt;
</code></pre>
<h4 id="display-partition-information-by-using-other-showplan-methods">Display partition information by using other Showplan methods</h4>
<p>The Showplan methods <code>SHOWPLAN_ALL</code>, <code>SHOWPLAN_TEXT</code>, and <code>STATISTICS PROFILE</code> don't report the partition information described in this article, with the following exception. As part of the <code>SEEK</code> predicate, the partitions to be accessed are identified by a range predicate on the computed column representing the partition ID. The following example shows the <code>SEEK</code> predicate for a <code>Clustered Index Seek</code> operator. Partitions 2 and 3 are accessed, and the seek operator filters on the rows that meet the condition <code>date_id BETWEEN 20080802 AND 20080902</code>.</p>
<pre><code class="lang-output">|--Clustered Index Seek(OBJECT:([db_sales_test].[dbo].[fact_sales].[ci]),
        SEEK:([PtnId1000] &gt;= (2) AND [PtnId1000] \&lt;= (3)
                AND [db_sales_test].[dbo].[fact_sales].[date_id] &gt;= (20080802)
                AND [db_sales_test].[dbo].[fact_sales].[date_id] &lt;= (20080902))
                ORDERED FORWARD)
</code></pre>
<h4 id="interpret-execution-plans-for-partitioned-heaps">Interpret execution plans for partitioned heaps</h4>
<p>A partitioned heap is treated as a logical index on the partition ID. Partition elimination on a partitioned heap is represented in an execution plan as a <code>Table Scan</code> operator with a <code>SEEK</code> predicate on partition ID. The following example shows the Showplan information provided:</p>
<pre><code class="lang-sql">|-- Table Scan (OBJECT: ([db].[dbo].[T]), SEEK: ([PtnId1001]=[Expr1011]) ORDERED FORWARD)
</code></pre>
<h4 id="interpret-execution-plans-for-collocated-joins">Interpret execution plans for collocated joins</h4>
<p>Join collocation can occur when two tables are partitioned using the same or equivalent partitioning function and the partitioning columns from both sides of the join are specified in the join condition of the query. The Query Optimizer can generate a plan where the partitions of each table that have equal partition IDs are joined separately. Collocated joins can be faster than non-collocated joins because they can require less memory and processing time. The Query Optimizer chooses a non-collocated plan or a collocated plan based on cost estimates.</p>
<p>In a collocated plan, the <code>Nested Loops</code> join reads one or more joined table or index partitions from the inner side. The numbers within the <code>Constant Scan</code> operators represent the partition numbers.</p>
<p>When parallel plans for collocated joins are generated for partitioned tables or indexes, a Parallelism operator appears between the <code>Constant Scan</code> and the <code>Nested Loops</code> join operators. In this case, multiple worker threads on the outer side of the join each read and work on a different partition.</p>
<p>The following illustration demonstrates a parallel query plan for a collocated join.</p>
<p><span class="mx-imgBorder">
<img src="media/query-processing-architecture-guide/colocated-join.gif?view=sql-server-ver17" alt="Diagram of a colocated join." data-linktype="relative-path">
</span>
</p>
<h4 id="parallel-query-execution-strategy-for-partitioned-objects">Parallel query execution strategy for partitioned objects</h4>
<p>The query processor uses a parallel execution strategy for queries that select from partitioned objects. As part of the execution strategy, the query processor determines the table partitions required for the query, and the proportion of worker threads to allocate to each partition. In most cases, the query processor allocates an equal or almost equal number of worker threads to each partition, and then executes the query in parallel across the partitions. The following paragraphs explain worker thread allocation in greater detail.</p>
<p><span class="mx-imgBorder">
<img src="media/query-processing-architecture-guide/thread-part-1.gif?view=sql-server-ver17" alt="Diagram of a worker thread, part 1." data-linktype="relative-path">
</span>
</p>
<p>If the number of worker threads is less than the number of partitions, the query processor assigns each worker thread to a different partition, initially leaving one or more partitions without an assigned worker thread. When a worker thread finishes executing on a partition, the query processor assigns it to the next partition until each partition has been assigned a single worker thread. This is the only case in which the query processor reallocates worker threads to other partitions.</p>
<p>Shows worker thread reassigned after it finishes. If the number of worker threads is equal to the number of partitions, the query processor assigns one worker thread to each partition. When a worker thread finishes, it isn't reallocated to another partition.</p>
<p><span class="mx-imgBorder">
<img src="media/query-processing-architecture-guide/thread-part-2.gif?view=sql-server-ver17" alt="Diagram of a worker thread, part 2." data-linktype="relative-path">
</span>
</p>
<p>If the number of worker threads is greater than the number of partitions, the query processor allocates an equal number of worker threads to each partition. If the number of worker threads isn't an exact multiple of the number of partitions, the query processor allocates one additional worker thread to some partitions in order to use all of the available worker threads. If there is only one partition, all worker threads will be assigned to that partition. In the diagram below, there are four partitions and 14 worker threads. Each partition has 3 worker threads assigned, and two partitions have an additional worker thread, for a total of 14 worker thread assignments. When a worker thread finishes, it isn't reassigned to another partition.</p>
<p><span class="mx-imgBorder">
<img src="media/query-processing-architecture-guide/thread-part-3.gif?view=sql-server-ver17" alt="Diagram of a worker thread, part 3." data-linktype="relative-path">
</span>
</p>
<p>Although the above examples suggest a straightforward way to allocate worker threads, the actual strategy is more complex and accounts for other variables that occur during query execution. For example, if the table is partitioned and has a clustered index on column A and a query has the predicate clause <code>WHERE A IN (13, 17, 25)</code>, the query processor will allocate one or more worker threads to each of these three seek values (A=13, A=17, and A=25) instead of each table partition. It is only necessary to execute the query in the partitions that contain these values, and if all of these seek predicates happen to be in the same table partition, all of the worker threads will be assigned to the same table partition.</p>
<p>To take another example, suppose that the table has four partitions on column A with boundary points (10, 20, 30), an index on column B, and the query has a predicate clause <code>WHERE B IN (50, 100, 150)</code>. Because the table partitions are based on the values of A, the values of B can occur in any of the table partitions. Thus, the query processor will seek for each of the three values of B (50, 100, 150) in each of the four table partitions. The query processor will assign worker threads proportionately so that it can execute each of these 12 query scans in parallel.</p>
<table>
<thead>
<tr>
<th>Table partitions based on column A</th>
<th>Seeks for column B in each table partition</th>
</tr>
</thead>
<tbody>
<tr>
<td>Table Partition 1: A &lt; 10</td>
<td>B=50, B=100, B=150</td>
</tr>
<tr>
<td>Table Partition 2: A &gt;= 10 AND A &lt; 20</td>
<td>B=50, B=100, B=150</td>
</tr>
<tr>
<td>Table Partition 3: A &gt;= 20 AND A &lt; 30</td>
<td>B=50, B=100, B=150</td>
</tr>
<tr>
<td>Table Partition 4: A &gt;= 30</td>
<td>B=50, B=100, B=150</td>
</tr>
</tbody>
</table>
<h3 id="best-practices">Best practices</h3>
<p>To improve the performance of queries that access a large amount of data from large partitioned tables and indexes, we recommend the following best practices:</p>
<ul>
<li>Stripe each partition across many disks. This is especially relevant when using spinning disks.</li>
<li>When possible, use a server with enough main memory to fit frequently accessed partitions, or all partitions in memory, to reduce I/O cost.</li>
<li>If the data you query won't fit in memory, compress the tables and indexes. This will reduce I/O cost.</li>
<li>Use a server with fast processors and as many processor cores as you can afford, to take advantage of parallel query processing capability.</li>
<li>Ensure the server has sufficient I/O controller bandwidth.</li>
<li>Create a clustered index on every large partitioned table to take advantage of B-tree scanning optimizations.</li>
<li>Follow the best practice recommendations in the white paper, <a href="/en-us/previous-versions/sql/sql-server-2008/dd425070(v=sql.100)" data-linktype="absolute-path">The Data Loading Performance Guide</a>, when bulk loading data into partitioned tables.</li>
</ul>
<h3 id="example">Example</h3>
<p>The following example creates a test database containing a single table with seven partitions. Use the tools described previously when executing the queries in this example to view partitioning information for both compile-time and run-time plans.</p>
<div class="NOTE">
<p>Note</p>
<p>This example inserts more than 1 million rows into the table. Running this example can take several minutes depending on your hardware. Before executing this example, verify that you have more than 1.5 GB of disk space available.</p>
</div>
<pre><code class="lang-sql">USE master;
GO
IF DB_ID (N'db_sales_test') IS NOT NULL
    DROP DATABASE db_sales_test;
GO
CREATE DATABASE db_sales_test;
GO
USE db_sales_test;
GO
CREATE PARTITION FUNCTION [pf_range_fact](int) AS RANGE RIGHT FOR VALUES
(20080801, 20080901, 20081001, 20081101, 20081201, 20090101);
GO
CREATE PARTITION SCHEME [ps_fact_sales] AS PARTITION [pf_range_fact]
ALL TO ([PRIMARY]);
GO
CREATE TABLE fact_sales(date_id int, product_id int, store_id int,
    quantity int, unit_price numeric(7,2), other_data char(1000))
ON ps_fact_sales(date_id);
GO
CREATE CLUSTERED INDEX ci ON fact_sales(date_id);
GO
PRINT 'Loading...';
SET NOCOUNT ON;
DECLARE @i int;
SET @i = 1;
WHILE (@i&lt;1000000)
BEGIN
    INSERT INTO fact_sales VALUES(20080800 + (@i%30) + 1, @i%10000, @i%200, RAND() - 25, (@i%3) + 1, '');
    SET @i += 1;
END;
GO
DECLARE @i int;
SET @i = 1;
WHILE (@i&lt;10000)
BEGIN
    INSERT INTO fact_sales VALUES(20080900 + (@i%30) + 1, @i%10000, @i%200, RAND() - 25, (@i%3) + 1, '');
    SET @i += 1;
END;
PRINT 'Done.';
GO
-- Two-partition query.
SET STATISTICS XML ON;
GO
SELECT date_id, SUM(quantity*unit_price) AS total_price
FROM fact_sales
WHERE date_id BETWEEN 20080802 AND 20080902
GROUP BY date_id ;
GO
SET STATISTICS XML OFF;
GO
-- Single-partition query.
SET STATISTICS XML ON;
GO
SELECT date_id, SUM(quantity*unit_price) AS total_price
FROM fact_sales
WHERE date_id BETWEEN 20080801 AND 20080831
GROUP BY date_id;
GO
SET STATISTICS XML OFF;
GO
</code></pre>
<h2 id="related-content">Related content</h2>
<ul>
<li><a href="showplan-logical-and-physical-operators-reference?view=sql-server-ver17" data-linktype="relative-path">Logical and physical showplan operator reference</a></li>
<li><a href="extended-events/extended-events?view=sql-server-ver17" data-linktype="relative-path">Extended Events overview</a></li>
<li><a href="performance/best-practice-with-the-query-store?view=sql-server-ver17" data-linktype="relative-path">Best practices for monitoring workloads with Query Store</a></li>
<li><a href="performance/cardinality-estimation-sql-server?view=sql-server-ver17" data-linktype="relative-path">Cardinality Estimation (SQL Server)</a></li>
<li><a href="performance/intelligent-query-processing?view=sql-server-ver17" data-linktype="relative-path">Intelligent query processing in SQL databases</a></li>
<li><a href="../t-sql/language-elements/operator-precedence-transact-sql?view=sql-server-ver17" data-linktype="relative-path">Operator Precedence (Transact-SQL)</a></li>
<li><a href="performance/execution-plans?view=sql-server-ver17" data-linktype="relative-path">Execution plan overview</a></li>
<li><a href="performance/performance-center-for-sql-server-database-engine-and-azure-sql-database?view=sql-server-ver17" data-linktype="relative-path">Performance Center for SQL Server Database Engine and Azure SQL Database</a></li>
</ul>
</div>
					
		<div
			id="ms--inline-notifications"
			class="margin-block-xs"
			data-bi-name="inline-notification"
		></div>
	 
		<div
			id="assertive-live-region"
			role="alert"
			aria-live="assertive"
			class="visually-hidden"
			aria-relevant="additions"
			aria-atomic="true"
		></div>
		<div
			id="polite-live-region"
			role="status"
			aria-live="polite"
			class="visually-hidden"
			aria-relevant="additions"
			aria-atomic="true"
		></div>
	
					
		<!-- feedback section -->
		<section
			id="site-user-feedback-footer"
			class="font-size-sm margin-top-md display-none-print display-none-desktop"
			data-test-id="site-user-feedback-footer"
			data-bi-name="site-feedback-section"
		>
			<hr class="hr" />
			<h2 id="ms--feedback" class="title is-3">Feedback</h2>
			<div class="display-flex flex-wrap-wrap align-items-center">
				<p class="font-weight-semibold margin-xxs margin-left-none">
					Was this page helpful?
				</p>
				<div class="buttons">
					<button
						class="thumb-rating-button like button button-primary button-sm"
						data-test-id="footer-rating-yes"
						data-binary-rating-response="rating-yes"
						type="button"
						title="This article is helpful"
						data-bi-name="button-rating-yes"
						aria-pressed="false"
					>
						<span class="icon" aria-hidden="true">
							<span class="docon docon-like"></span>
						</span>
						<span>Yes</span>
					</button>
					<button
						class="thumb-rating-button dislike button button-primary button-sm"
						id="standard-rating-no-button"
						hidden
						data-test-id="footer-rating-no"
						data-binary-rating-response="rating-no"
						type="button"
						title="This article is not helpful"
						data-bi-name="button-rating-no"
						aria-pressed="false"
					>
						<span class="icon" aria-hidden="true">
							<span class="docon docon-dislike"></span>
						</span>
						<span>No</span>
					</button>
					<details
						class="popover popover-top"
						id="mobile-help-popover"
						data-test-id="footer-feedback-popover"
					>
						<summary
							class="thumb-rating-button dislike button button-primary button-sm"
							data-test-id="details-footer-rating-no"
							data-binary-rating-response="rating-no"
							title="This article is not helpful"
							data-bi-name="button-rating-no"
							aria-pressed="false"
							data-bi-an="feedback-unhelpful-popover"
						>
							<span class="icon" aria-hidden="true">
								<span class="docon docon-dislike"></span>
							</span>
							<span>No</span>
						</summary>
						<div
							class="popover-content width-200 width-300-tablet"
							role="dialog"
							aria-labelledby="popover-heading"
							aria-describedby="popover-description"
						>
							<p id="popover-heading" class="font-size-lg margin-bottom-xxs font-weight-semibold">
								Need help with this topic?
							</p>
							<p id="popover-description" class="font-size-sm margin-bottom-xs">
								Want to try using Ask Learn to clarify or guide you through this topic?
							</p>
							
		<div class="buttons flex-direction-row flex-wrap justify-content-center gap-xxs">
			<div>
		<button
			class="button button-sm border inner-focus display-none margin-right-xxs"
			data-bi-name="ask-learn-assistant-entry-troubleshoot"
			data-test-id="ask-learn-assistant-modal-entry-mobile-feedback"
			data-ask-learn-modal-entry-feedback
			data-bi-an=feedback-unhelpful-popover
			type="button"
			style="min-width: max-content;"
			aria-expanded="false"
			aria-label="Ask Learn"
			hidden
		>
			<span class="icon font-size-lg" aria-hidden="true">
				<span class="docon docon-chat-sparkle-fill gradient-ask-learn-logo"></span>
			</span>
		</button>
		<button
			class="button button-sm display-inline-flex display-none-desktop flex-shrink-0 margin-right-xxs border-color-ask-learn margin-right-xxs"
			data-bi-name="ask-learn-assistant-entry-troubleshoot"
			data-bi-an=feedback-unhelpful-popover
			data-test-id="ask-learn-assistant-modal-entry-tablet-feedback"
			data-ask-learn-modal-entry-feedback
			type="button"
			style="min-width: max-content;"
			aria-expanded="false"
			hidden
		>
			<span class="icon font-size-lg" aria-hidden="true">
				<span class="docon docon-chat-sparkle-fill gradient-ask-learn-logo"></span>
			</span>
			<span>Ask Learn</span>
		</button>
		<button
			class="button button-sm display-none flex-shrink-0 display-inline-flex-desktop margin-right-xxs border-color-ask-learn margin-right-xxs"
			data-bi-name="ask-learn-assistant-entry-troubleshoot"
			data-bi-an=feedback-unhelpful-popover
			data-test-id="ask-learn-assistant-flyout-entry-feedback"
			data-ask-learn-flyout-entry-show-only
			data-flyout-button="toggle"
			type="button"
			style="min-width: max-content;"
			aria-expanded="false"
			aria-controls="ask-learn-flyout"
			hidden
		>
			<span class="icon font-size-lg" aria-hidden="true">
				<span class="docon docon-chat-sparkle-fill gradient-ask-learn-logo"></span>
			</span>
			<span>Ask Learn</span>
		</button>
	</div>
			<button
				type="button"
				class="button button-sm margin-right-xxs"
				data-help-option="suggest-fix"
				data-bi-name="feedback-suggest"
				data-bi-an="feedback-unhelpful-popover"
				data-test-id="suggest-fix"
			>
				<span class="icon" aria-hidden="true">
					<span class="docon docon-feedback"></span>
				</span>
				<span> Suggest a fix? </span>
			</button>
		</div>
	
						</div>
					</details>
				</div>
			</div>
		</section>
		<!-- end feedback section -->
	
				</div>
				
		<div id="ms--additional-resources-mobile" class="display-none-print">
			<hr class="hr" hidden />
			<h2 id="ms--additional-resources-mobile-heading" class="title is-3" hidden>
				Additional resources
			</h2>
			
		<section
			id="right-rail-recommendations-mobile"
			class=""
			data-bi-name="recommendations"
			hidden
		></section>
	 
		<section
			id="right-rail-training-mobile"
			class=""
			data-bi-name="learning-resource-card"
			hidden
		></section>
	 
		<section
			id="right-rail-events-mobile"
			class=""
			data-bi-name="events-card"
			hidden
		></section>
	 
		<section
			id="right-rail-qna-mobile"
			class="margin-top-xxs"
			data-bi-name="qna-link-card"
			hidden
		></section>
	
		</div>
	 
		<div
			id="article-metadata-footer"
			data-bi-name="article-metadata-footer"
			data-test-id="article-metadata-footer"
			class="page-metadata-container"
		>
			<hr class="hr" />
			<ul class="metadata page-metadata" data-bi-name="page info" lang="en-us" dir="ltr">
				<li class="visibility-hidden-visual-diff">
			<span class="badge badge-sm text-wrap-pretty">
				<span>Last updated on <local-time format="twoDigitNumeric"
		datetime="2025-11-18T15:49:00.000Z"
		data-article-date-source="calculated"
		class="is-invisible"
	>
		2025-11-18
	</local-time></span>
			</span>
		</li>
			</ul>
		</div>
	
			</div>
			
		<div
			id="action-panel"
			role="region"
			aria-label="Action Panel"
			class="action-panel"
			tabindex="-1"
		></div>
	
		
				</main>
				<aside
					id="layout-body-aside"
					class="layout-body-aside "
					data-bi-name="aside"
			  >
					
		<div
			id="ms--additional-resources"
			class="right-container padding-sm display-none display-block-desktop height-full"
			data-bi-name="pageactions"
			role="complementary"
			aria-label="Additional resources"
		>
			<div id="affixed-right-container" data-bi-name="right-column">
				
		<nav
			id="side-doc-outline"
			class="doc-outline border-bottom padding-bottom-xs margin-bottom-xs"
			data-bi-name="intopic toc"
			aria-label="In this article"
		>
			<h3>In this article</h3>
		</nav>
	
				<!-- Feedback -->
				
		<section
			id="ms--site-user-feedback-right-rail"
			class="font-size-sm display-none-print"
			data-test-id="site-user-feedback-right-rail"
			data-bi-name="site-feedback-right-rail"
		>
			<p class="font-weight-semibold margin-bottom-xs">Was this page helpful?</p>
			<div class="buttons">
				<button
					class="thumb-rating-button like button button-primary button-sm"
					data-test-id="right-rail-rating-yes"
					data-binary-rating-response="rating-yes"
					type="button"
					title="This article is helpful"
					data-bi-name="button-rating-yes"
					aria-pressed="false"
				>
					<span class="icon" aria-hidden="true">
						<span class="docon docon-like"></span>
					</span>
					<span>Yes</span>
				</button>
				<button
					class="thumb-rating-button dislike button button-primary button-sm"
					id="right-rail-no-button"
					hidden
					data-test-id="right-rail-rating-no"
					data-binary-rating-response="rating-no"
					type="button"
					title="This article is not helpful"
					data-bi-name="button-rating-no"
					aria-pressed="false"
				>
					<span class="icon" aria-hidden="true">
						<span class="docon docon-dislike"></span>
					</span>
					<span>No</span>
				</button>
				<details class="popover popover-right" id="help-popover" data-test-id="feedback-popover">
					<summary
						tabindex="0"
						class="thumb-rating-button dislike button button-primary button-sm"
						data-test-id="details-right-rail-rating-no"
						data-binary-rating-response="rating-no"
						title="This article is not helpful"
						data-bi-name="button-rating-no"
						aria-pressed="false"
						data-bi-an="feedback-unhelpful-popover"
					>
						<span class="icon" aria-hidden="true">
							<span class="docon docon-dislike"></span>
						</span>
						<span>No</span>
					</summary>
					<div
						class="popover-content width-200 width-300-tablet"
						role="dialog"
						aria-labelledby="popover-heading"
						aria-describedby="popover-description"
					>
						<p
							id="popover-heading-right-rail"
							class="font-size-lg margin-bottom-xxs font-weight-semibold"
						>
							Need help with this topic?
						</p>
						<p id="popover-description-right-rail" class="font-size-sm margin-bottom-xs">
							Want to try using Ask Learn to clarify or guide you through this topic?
						</p>
						
		<div class="buttons flex-direction-row flex-wrap justify-content-center gap-xxs">
			<div>
		<button
			class="button button-sm border inner-focus display-none margin-right-xxs"
			data-bi-name="ask-learn-assistant-entry-troubleshoot"
			data-test-id="ask-learn-assistant-modal-entry-mobile-feedback"
			data-ask-learn-modal-entry-feedback
			data-bi-an=feedback-unhelpful-popover
			type="button"
			style="min-width: max-content;"
			aria-expanded="false"
			aria-label="Ask Learn"
			hidden
		>
			<span class="icon font-size-lg" aria-hidden="true">
				<span class="docon docon-chat-sparkle-fill gradient-ask-learn-logo"></span>
			</span>
		</button>
		<button
			class="button button-sm display-inline-flex display-none-desktop flex-shrink-0 margin-right-xxs border-color-ask-learn margin-right-xxs"
			data-bi-name="ask-learn-assistant-entry-troubleshoot"
			data-bi-an=feedback-unhelpful-popover
			data-test-id="ask-learn-assistant-modal-entry-tablet-feedback"
			data-ask-learn-modal-entry-feedback
			type="button"
			style="min-width: max-content;"
			aria-expanded="false"
			hidden
		>
			<span class="icon font-size-lg" aria-hidden="true">
				<span class="docon docon-chat-sparkle-fill gradient-ask-learn-logo"></span>
			</span>
			<span>Ask Learn</span>
		</button>
		<button
			class="button button-sm display-none flex-shrink-0 display-inline-flex-desktop margin-right-xxs border-color-ask-learn margin-right-xxs"
			data-bi-name="ask-learn-assistant-entry-troubleshoot"
			data-bi-an=feedback-unhelpful-popover
			data-test-id="ask-learn-assistant-flyout-entry-feedback"
			data-ask-learn-flyout-entry-show-only
			data-flyout-button="toggle"
			type="button"
			style="min-width: max-content;"
			aria-expanded="false"
			aria-controls="ask-learn-flyout"
			hidden
		>
			<span class="icon font-size-lg" aria-hidden="true">
				<span class="docon docon-chat-sparkle-fill gradient-ask-learn-logo"></span>
			</span>
			<span>Ask Learn</span>
		</button>
	</div>
			<button
				type="button"
				class="button button-sm margin-right-xxs"
				data-help-option="suggest-fix"
				data-bi-name="feedback-suggest"
				data-bi-an="feedback-unhelpful-popover"
				data-test-id="suggest-fix"
			>
				<span class="icon" aria-hidden="true">
					<span class="docon docon-feedback"></span>
				</span>
				<span> Suggest a fix? </span>
			</button>
		</div>
	
					</div>
				</details>
			</div>
		</section>
	
			</div>
		</div>
	
			  </aside> <section
					id="layout-body-flyout"
					class="layout-body-flyout "
					data-bi-name="flyout"
			  >
					 <div
	class="height-full border-left background-color-body-medium"
	id="ask-learn-flyout"
></div>
			  </section> <div class="layout-body-footer " data-bi-name="layout-footer">
		<footer
			id="footer"
			data-test-id="footer"
			data-bi-name="footer"
			class="footer-layout has-padding has-default-focus border-top  uhf-container"
			role="contentinfo"
		>
			<div class="display-flex gap-xs flex-wrap-wrap is-full-height padding-right-lg-desktop">
				
		<a
			data-mscc-ic="false"
			href="#"
			data-bi-name="select-locale"
			class="locale-selector-link flex-shrink-0 button button-sm button-clear external-link-indicator"
			id=""
			title=""
			><span class="icon" aria-hidden="true"
				><span class="docon docon-world"></span></span
			><span class="local-selector-link-text">en-us</span></a
		>
	 <div class="ccpa-privacy-link" data-ccpa-privacy-link hidden>
		
		<a
			data-mscc-ic="false"
			href="https://aka.ms/yourcaliforniaprivacychoices"
			data-bi-name="your-privacy-choices"
			class="button button-sm button-clear flex-shrink-0 external-link-indicator"
			id=""
			title=""
			>
		<svg
			xmlns="http://www.w3.org/2000/svg"
			viewBox="0 0 30 14"
			xml:space="preserve"
			height="16"
			width="43"
			aria-hidden="true"
			focusable="false"
		>
			<path
				d="M7.4 12.8h6.8l3.1-11.6H7.4C4.2 1.2 1.6 3.8 1.6 7s2.6 5.8 5.8 5.8z"
				style="fill-rule:evenodd;clip-rule:evenodd;fill:#fff"
			></path>
			<path
				d="M22.6 0H7.4c-3.9 0-7 3.1-7 7s3.1 7 7 7h15.2c3.9 0 7-3.1 7-7s-3.2-7-7-7zm-21 7c0-3.2 2.6-5.8 5.8-5.8h9.9l-3.1 11.6H7.4c-3.2 0-5.8-2.6-5.8-5.8z"
				style="fill-rule:evenodd;clip-rule:evenodd;fill:#06f"
			></path>
			<path
				d="M24.6 4c.2.2.2.6 0 .8L22.5 7l2.2 2.2c.2.2.2.6 0 .8-.2.2-.6.2-.8 0l-2.2-2.2-2.2 2.2c-.2.2-.6.2-.8 0-.2-.2-.2-.6 0-.8L20.8 7l-2.2-2.2c-.2-.2-.2-.6 0-.8.2-.2.6-.2.8 0l2.2 2.2L23.8 4c.2-.2.6-.2.8 0z"
				style="fill:#fff"
			></path>
			<path
				d="M12.7 4.1c.2.2.3.6.1.8L8.6 9.8c-.1.1-.2.2-.3.2-.2.1-.5.1-.7-.1L5.4 7.7c-.2-.2-.2-.6 0-.8.2-.2.6-.2.8 0L8 8.6l3.8-4.5c.2-.2.6-.2.9 0z"
				style="fill:#06f"
			></path>
		</svg>
	
			<span>Your Privacy Choices</span></a
		>
	
	</div>
				<div class="flex-shrink-0">
		<div class="dropdown has-caret-up">
			<button
				data-test-id="theme-selector-button"
				class="dropdown-trigger button button-clear button-sm inner-focus theme-dropdown-trigger"
				aria-controls="{{ themeMenuId }}"
				aria-expanded="false"
				title="Theme"
				data-bi-name="theme"
			>
				<span class="icon">
					<span class="docon docon-sun" aria-hidden="true"></span>
				</span>
				<span>Theme</span>
				<span class="icon expanded-indicator" aria-hidden="true">
					<span class="docon docon-chevron-down-light"></span>
				</span>
			</button>
			<div class="dropdown-menu" id="{{ themeMenuId }}" role="menu">
				<ul class="theme-selector padding-xxs" data-test-id="theme-dropdown-menu">
					<li class="theme display-block">
						<button
							class="button button-clear button-sm theme-control button-block justify-content-flex-start text-align-left"
							data-theme-to="light"
						>
							<span class="theme-light margin-right-xxs">
								<span
									class="theme-selector-icon border display-inline-block has-body-background"
									aria-hidden="true"
								>
									<svg class="svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 22 14">
										<rect width="22" height="14" class="has-fill-body-background" />
										<rect x="5" y="5" width="12" height="4" class="has-fill-secondary" />
										<rect x="5" y="2" width="2" height="1" class="has-fill-secondary" />
										<rect x="8" y="2" width="2" height="1" class="has-fill-secondary" />
										<rect x="11" y="2" width="3" height="1" class="has-fill-secondary" />
										<rect x="1" y="1" width="2" height="2" class="has-fill-secondary" />
										<rect x="5" y="10" width="7" height="2" rx="0.3" class="has-fill-primary" />
										<rect x="19" y="1" width="2" height="2" rx="1" class="has-fill-secondary" />
									</svg>
								</span>
							</span>
							<span role="menuitem"> Light </span>
						</button>
					</li>
					<li class="theme display-block">
						<button
							class="button button-clear button-sm theme-control button-block justify-content-flex-start text-align-left"
							data-theme-to="dark"
						>
							<span class="theme-dark margin-right-xxs">
								<span
									class="border theme-selector-icon display-inline-block has-body-background"
									aria-hidden="true"
								>
									<svg class="svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 22 14">
										<rect width="22" height="14" class="has-fill-body-background" />
										<rect x="5" y="5" width="12" height="4" class="has-fill-secondary" />
										<rect x="5" y="2" width="2" height="1" class="has-fill-secondary" />
										<rect x="8" y="2" width="2" height="1" class="has-fill-secondary" />
										<rect x="11" y="2" width="3" height="1" class="has-fill-secondary" />
										<rect x="1" y="1" width="2" height="2" class="has-fill-secondary" />
										<rect x="5" y="10" width="7" height="2" rx="0.3" class="has-fill-primary" />
										<rect x="19" y="1" width="2" height="2" rx="1" class="has-fill-secondary" />
									</svg>
								</span>
							</span>
							<span role="menuitem"> Dark </span>
						</button>
					</li>
					<li class="theme display-block">
						<button
							class="button button-clear button-sm theme-control button-block justify-content-flex-start text-align-left"
							data-theme-to="high-contrast"
						>
							<span class="theme-high-contrast margin-right-xxs">
								<span
									class="border theme-selector-icon display-inline-block has-body-background"
									aria-hidden="true"
								>
									<svg class="svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 22 14">
										<rect width="22" height="14" class="has-fill-body-background" />
										<rect x="5" y="5" width="12" height="4" class="has-fill-secondary" />
										<rect x="5" y="2" width="2" height="1" class="has-fill-secondary" />
										<rect x="8" y="2" width="2" height="1" class="has-fill-secondary" />
										<rect x="11" y="2" width="3" height="1" class="has-fill-secondary" />
										<rect x="1" y="1" width="2" height="2" class="has-fill-secondary" />
										<rect x="5" y="10" width="7" height="2" rx="0.3" class="has-fill-primary" />
										<rect x="19" y="1" width="2" height="2" rx="1" class="has-fill-secondary" />
									</svg>
								</span>
							</span>
							<span role="menuitem"> High contrast </span>
						</button>
					</li>
				</ul>
			</div>
		</div>
	</div>
			</div>
			<ul class="links" data-bi-name="footerlinks">
				<li class="manage-cookies-holder" hidden=""></li>
				<li>
		
		<a
			data-mscc-ic="false"
			href="https://learn.microsoft.com/en-us/principles-for-ai-generated-content"
			data-bi-name="aiDisclaimer"
			class=" external-link-indicator"
			id=""
			title=""
			>AI Disclaimer</a
		>
	
	</li><li>
		
		<a
			data-mscc-ic="false"
			href="https://learn.microsoft.com/en-us/previous-versions/"
			data-bi-name="archivelink"
			class=" external-link-indicator"
			id=""
			title=""
			>Previous Versions</a
		>
	
	</li> <li>
		
		<a
			data-mscc-ic="false"
			href="https://techcommunity.microsoft.com/t5/microsoft-learn-blog/bg-p/MicrosoftLearnBlog"
			data-bi-name="bloglink"
			class=" external-link-indicator"
			id=""
			title=""
			>Blog</a
		>
	
	</li> <li>
		
		<a
			data-mscc-ic="false"
			href="https://learn.microsoft.com/en-us/contribute"
			data-bi-name="contributorGuide"
			class=" external-link-indicator"
			id=""
			title=""
			>Contribute</a
		>
	
	</li><li>
		
		<a
			data-mscc-ic="false"
			href="https://go.microsoft.com/fwlink/?LinkId=521839"
			data-bi-name="privacy"
			class=" external-link-indicator"
			id=""
			title=""
			>Privacy</a
		>
	
	</li><li>
		
		<a
			data-mscc-ic="false"
			href="https://learn.microsoft.com/en-us/legal/termsofuse"
			data-bi-name="termsofuse"
			class=" external-link-indicator"
			id=""
			title=""
			>Terms of Use</a
		>
	
	</li><li>
		
		<a
			data-mscc-ic="false"
			href="https://www.microsoft.com/legal/intellectualproperty/Trademarks/"
			data-bi-name="trademarks"
			class=" external-link-indicator"
			id=""
			title=""
			>Trademarks</a
		>
	
	</li>
				<li>&copy; Microsoft 2026</li>
			</ul>
		</footer>
	</footer>
			</body>
		</html>