<!doctype html>
<html lang="en">
 <head>
  <title>PostgreSQL: Documentation: 8.1: Performance Tips</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta http-equiv="Content-Type" content="text/xhtml; charset=utf-8" />
   
  <meta name="theme-color" content="#336791"/>
  <meta name="copyright" content="The PostgreSQL Global Development Group" />
  <meta property="og:url" content="https://www.postgresql.org/docs/8.1/performance-tips.html" />
  <meta property="og:type" content="article" />

  <meta property="article:published_time" content="2012-01-01T00:00:00" />
  <meta property="og:image" content="https://www.postgresql.org/media/img/about/press/elephant.png" />
  <meta property="og:title" content="Performance Tips" />
  <meta property="og:description" content="" />
  <meta property="og:site_name" content="PostgreSQL Documentation" />
  <link href="/media/css/fontawesome.css?77152761" rel="stylesheet">
  <link rel="stylesheet" href="/media/css/bootstrap-4.4.1.min.css">
  <link rel="shortcut icon" href="/favicon.ico" />
  
  <link rel="stylesheet" type="text/css" href="/dyncss/base.css?77152761">

  <script src="/media/js/theme.js?77152761"></script>

  
  <meta name="robots" content="nofollow" />

  <link rel="canonical" href="https://www.postgresql.org/docs/current/performance-tips.html" />


  </head>
  <body>
    <div class="container-fluid">
      <div class="row justify-content-md-center">
        <div class="col">
          <!-- Header -->
          <nav class="navbar navbar-expand-lg navbar-light bg-light">
            <a class="navbar-brand p-0" href="/">
              <img class="logo" src="/media/img/about/press/elephant.png" alt="PostgreSQL Elephant Logo">
            </a>
            <input type="checkbox" id="navbar-toggler" aria-controls="pgNavbar" aria-expanded="false" aria-label="Toggle navigation">
            <label for="navbar-toggler" id="navbar-toggler-label" class="navbar-toggler" tabindex="0"><span class="navbar-toggler-icon"></span></label>
            <div class="navbar-collapse" id="pgNavbar">
              <ul class="navbar-nav mr-auto">
                <li class="nav-item p-2"><a href="/" title="Home">Home</a></li>
                <li class="nav-item p-2"><a href="/about/" title="About">About</a></li>
                <li class="nav-item p-2"><a href="/download/" title="Download">Download</a></li>
                <li class="nav-item p-2"><a href="/docs/" title="Documentation">Documentation</a></li>
                <li class="nav-item p-2"><a href="/community/" title="Community">Community</a></li>
                <li class="nav-item p-2"><a href="/developer/" title="Developers">Developers</a></li>
                <li class="nav-item p-2"><a href="/support/" title="Support">Support</a></li>
                <li class="nav-item p-2"><a href="/about/donate/" title="Donate">Donate</a></li>
                <li class="nav-item p-2"><a href="/account/" title="Your account">Your account</a></li>
              </ul>
              <form role="search" method="get" action="/search/">
                <div class="input-group">
                  <input id="q" name="q" type="text" size="20" maxlength="255" accesskey="s"  class="form-control" placeholder="Search for...">
                  <span class="input-group-btn">
                    <button class="btn btn-default" type="submit"><i class="fas fa-search"></i></button>
                  </span>
                </div><!-- /input-group -->
              </form>
              <form id="form-theme" class="form-inline d-none">
                <button id="btn-theme" class="btn btn-default ml-1" type="button"></button>
              </form>
            </div>
          </nav>
        </div>
      </div>
      <div class="row justify-content-center pg-shout-box">
        <div class="col text-white text-center">February 16, 2026: <a href="/about/news/out-of-cycle-release-scheduled-for-february-26-2026-3241/">
  Out-of-cycle release scheduled for February 26, 2026
</a>
</div>
      </div>
    </div>
    
    <div class="container-fluid margin">
      <div class="row">
        <div id="pgContentWrap" class="col-11">
          <div class="row">
            <div class="col-md-6 mb-2">
              <div class="row">
                <div class="col">
                  <div>
                    <a href="/docs/" title="Documentation">Documentation</a> &rarr; <a href="/docs/8.1/index.html">PostgreSQL 8.1</a>
                  </div>
                </div>
              </div>
              
                <div class="row">
                  <div class="col">
                    Supported Versions:
                      
                        
                        
                          <a href="/docs/current/performance-tips.html" title="PostgreSQL 18 - Performance Tips" >Current</a>
                          (<a href="/docs/18/performance-tips.html" title="PostgreSQL 18 - Performance Tips" >18</a>)
                        
                      
                         / 
                        
                          <a href="/docs/17/performance-tips.html" title="PostgreSQL 17 - Performance Tips" >17</a>
                        
                      
                         / 
                        
                          <a href="/docs/16/performance-tips.html" title="PostgreSQL 16 - Performance Tips" >16</a>
                        
                      
                         / 
                        
                          <a href="/docs/15/performance-tips.html" title="PostgreSQL 15 - Performance Tips" >15</a>
                        
                      
                         / 
                        
                          <a href="/docs/14/performance-tips.html" title="PostgreSQL 14 - Performance Tips" >14</a>
                        
                      
                  </div>
                </div>
              
              
                <div class="row">
                  <div class="col">
                    Development Versions:
                    
                      
                      <a href="/docs/devel/performance-tips.html" title="PostgreSQL devel - Performance Tips"  rel="nofollow">devel</a>
                    
                  </div>
                </div>
              
              
                <div class="row">
                  <div class="col-12">
                    Unsupported versions:
                    
                      
                      <a href="/docs/13/performance-tips.html" title="PostgreSQL 13 - Performance Tips"  rel="nofollow">13</a>
                    
                       / 
                      <a href="/docs/12/performance-tips.html" title="PostgreSQL 12 - Performance Tips"  rel="nofollow">12</a>
                    
                       / 
                      <a href="/docs/11/performance-tips.html" title="PostgreSQL 11 - Performance Tips"  rel="nofollow">11</a>
                    
                       / 
                      <a href="/docs/10/performance-tips.html" title="PostgreSQL 10 - Performance Tips"  rel="nofollow">10</a>
                    
                       / 
                      <a href="/docs/9.6/performance-tips.html" title="PostgreSQL 9.6 - Performance Tips"  rel="nofollow">9.6</a>
                    
                       / 
                      <a href="/docs/9.5/performance-tips.html" title="PostgreSQL 9.5 - Performance Tips"  rel="nofollow">9.5</a>
                    
                       / 
                      <a href="/docs/9.4/performance-tips.html" title="PostgreSQL 9.4 - Performance Tips"  rel="nofollow">9.4</a>
                    
                       / 
                      <a href="/docs/9.3/performance-tips.html" title="PostgreSQL 9.3 - Performance Tips"  rel="nofollow">9.3</a>
                    
                       / 
                      <a href="/docs/9.2/performance-tips.html" title="PostgreSQL 9.2 - Performance Tips"  rel="nofollow">9.2</a>
                    
                       / 
                      <a href="/docs/9.1/performance-tips.html" title="PostgreSQL 9.1 - Performance Tips"  rel="nofollow">9.1</a>
                    
                       / 
                      <a href="/docs/9.0/performance-tips.html" title="PostgreSQL 9.0 - Performance Tips"  rel="nofollow">9.0</a>
                    
                       / 
                      <a href="/docs/8.4/performance-tips.html" title="PostgreSQL 8.4 - Performance Tips"  rel="nofollow">8.4</a>
                    
                       / 
                      <a href="/docs/8.3/performance-tips.html" title="PostgreSQL 8.3 - Performance Tips"  rel="nofollow">8.3</a>
                    
                       / 
                      <a href="/docs/8.2/performance-tips.html" title="PostgreSQL 8.2 - Performance Tips"  rel="nofollow">8.2</a>
                    
                       / 
                      <a href="/docs/8.1/performance-tips.html" title="PostgreSQL 8.1 - Performance Tips" class="docs-version-selected" rel="nofollow">8.1</a>
                    
                       / 
                      <a href="/docs/8.0/performance-tips.html" title="PostgreSQL 8.0 - Performance Tips"  rel="nofollow">8.0</a>
                    
                       / 
                      <a href="/docs/7.4/performance-tips.html" title="PostgreSQL 7.4 - Performance Tips"  rel="nofollow">7.4</a>
                    
                       / 
                      <a href="/docs/7.3/performance-tips.html" title="PostgreSQL 7.3 - Performance Tips"  rel="nofollow">7.3</a>
                    
                       / 
                      <a href="/docs/7.2/performance-tips.html" title="PostgreSQL 7.2 - Performance Tips"  rel="nofollow">7.2</a>
                    
                       / 
                      <a href="/docs/7.1/performance-tips.html" title="PostgreSQL 7.1 - Performance Tips"  rel="nofollow">7.1</a>
                    
                  </div>
                </div>
              
            </div>
            <div class="col-md-6 col-lg-5 offset-lg-1">
              <form id="docSearchForm" role="search" method="get" action="/search/">
                <input type="hidden" name="u" value="/docs/8.1/" />
                <div class="input-group">
                  <input type="text" id="q" name="q" class="form-control" placeholder="Search the documentation for..."/>
                  <span class="input-group-btn">
                    <button class="btn btn-default" type="submit"><i class="fas fa-search"></i></button>
                  </span>
                </div><!-- /input-group -->
              </form>
            </div>
          </div>

	  <div class="text-center alert-warning">
	    This documentation is for an unsupported version of PostgreSQL.<br/>
	    You may want to view the same page for the
	    <a href="/docs/current/performance-tips.html" title="PostgreSQL  - Performance Tips">current</a>
	    version, or one of the other supported versions listed above instead.
	  </div>

          <div id="docContent">
            <div class="NAVHEADER">
  <table summary="Header navigation table" width="100%" border="0"
  cellpadding="0" cellspacing="0">
    <tr>
      <th colspan="5" align="center" valign="bottom">PostgreSQL
      8.1.23 Documentation</th>
    </tr>

    <tr>
      <td width="10%" align="left" valign="top"><a href=
      "locking-indexes.html" accesskey="P">Prev</a></td>

      <td width="10%" align="left" valign="top"><a href=
      "mvcc.html">Fast Backward</a></td>

      <td width="60%" align="center" valign="bottom"></td>

      <td width="10%" align="right" valign="top"><a href=
      "admin.html">Fast Forward</a></td>

      <td width="10%" align="right" valign="top"><a href=
      "planner-stats.html" accesskey="N">Next</a></td>
    </tr>
  </table>
  <hr class="c1" width="100%" />
</div>

<div class="CHAPTER">
  <h1><a name="PERFORMANCE-TIPS" id="PERFORMANCE-TIPS"></a>Chapter
  13. Performance Tips</h1>

  <div class="TOC">
    <dl>
      <dt class="c2">Table of Contents</dt>

      <dt>13.1. <a href="performance-tips.html#USING-EXPLAIN">Using
      <tt class="COMMAND">EXPLAIN</tt></a></dt>

      <dt>13.2. <a href="planner-stats.html">Statistics Used by the
      Planner</a></dt>

      <dt>13.3. <a href="explicit-joins.html">Controlling the
      Planner with Explicit <tt class="LITERAL">JOIN</tt>
      Clauses</a></dt>

      <dt>13.4. <a href="populate.html">Populating a
      Database</a></dt>

      <dd>
        <dl>
          <dt>13.4.1. <a href=
          "populate.html#DISABLE-AUTOCOMMIT">Disable
          Autocommit</a></dt>

          <dt>13.4.2. <a href=
          "populate.html#POPULATE-COPY-FROM">Use <tt class=
          "COMMAND">COPY</tt></a></dt>

          <dt>13.4.3. <a href=
          "populate.html#POPULATE-RM-INDEXES">Remove
          Indexes</a></dt>

          <dt>13.4.4. <a href=
          "populate.html#POPULATE-RM-FKEYS">Remove Foreign Key
          Constraints</a></dt>

          <dt>13.4.5. <a href=
          "populate.html#POPULATE-WORK-MEM">Increase <tt class=
          "VARNAME">maintenance_work_mem</tt></a></dt>

          <dt>13.4.6. <a href=
          "populate.html#POPULATE-CHECKPOINT-SEGMENTS">Increase
          <tt class="VARNAME">checkpoint_segments</tt></a></dt>

          <dt>13.4.7. <a href="populate.html#POPULATE-ANALYZE">Run
          <tt class="COMMAND">ANALYZE</tt> Afterwards</a></dt>

          <dt>13.4.8. <a href="populate.html#POPULATE-PG-DUMP">Some
          Notes About <span class=
          "APPLICATION">pg_dump</span></a></dt>
        </dl>
      </dd>
    </dl>
  </div><a name="AEN15679" id="AEN15679"></a>

  <p>Query performance can be affected by many things. Some of
  these can be manipulated by the user, while others are
  fundamental to the underlying design of the system. This chapter
  provides some hints about understanding and tuning <span class=
  "PRODUCTNAME">PostgreSQL</span> performance.</p>

  <div class="SECT1">
    <h1 class="SECT1"><a name="USING-EXPLAIN" id=
    "USING-EXPLAIN">13.1. Using <tt class=
    "COMMAND">EXPLAIN</tt></a></h1><a name="AEN15686" id=
    "AEN15686"></a><a name="AEN15688" id="AEN15688"></a>

    <p><span class="PRODUCTNAME">PostgreSQL</span> devises a
    <i class="FIRSTTERM">query plan</i> for each query it is given.
    Choosing the right plan to match the query structure and the
    properties of the data is absolutely critical for good
    performance, so the system includes a complex <i class=
    "FIRSTTERM">planner</i> that tries to select good plans. You
    can use the <a class="c3" href="sql-explain.html">EXPLAIN</a>
    command to see what query plan the planner creates for any
    query. Plan-reading is an art that deserves an extensive
    tutorial, which this is not; but here is some basic
    information.</p>

    <p>The structure of a query plan is a tree of <i class=
    "FIRSTTERM">plan nodes</i>. Nodes at the bottom level are table
    scan nodes: they return raw rows from a table. There are
    different types of scan nodes for different table access
    methods: sequential scans, index scans, and bitmap index scans.
    If the query requires joining, aggregation, sorting, or other
    operations on the raw rows, then there will be additional nodes
    <span class="QUOTE">"atop"</span> the scan nodes to perform
    these operations. Again, there is usually more than one
    possible way to do these operations, so different node types
    can appear here too. The output of <tt class=
    "COMMAND">EXPLAIN</tt> has one line for each node in the plan
    tree, showing the basic node type plus the cost estimates that
    the planner made for the execution of that plan node. The first
    line (topmost node) has the estimated total execution cost for
    the plan; it is this number that the planner seeks to
    minimize.</p>

    <p>Here is a trivial example, just to show what the output
    looks like. <a name="AEN15700" href="#FTN.AEN15700" id=
    "AEN15700"><span class="footnote">[1]</span></a></p>
    <pre class="PROGRAMLISTING">
EXPLAIN SELECT * FROM tenk1;

                         QUERY PLAN
-------------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..458.00 rows=10000 width=244)
</pre>

    <p>The numbers that are quoted by <tt class=
    "COMMAND">EXPLAIN</tt> are:</p>

    <ul>
      <li>
        <p>Estimated start-up cost (Time expended before output
        scan can start, e.g., time to do the sorting in a sort
        node.)</p>
      </li>

      <li>
        <p>Estimated total cost (If all rows were to be retrieved,
        which they may not be: for example, a query with a
        <tt class="LITERAL">LIMIT</tt> clause will stop short of
        paying the total cost of the <tt class="LITERAL">Limit</tt>
        plan node's input node.)</p>
      </li>

      <li>
        <p>Estimated number of rows output by this plan node
        (Again, only if executed to completion.)</p>
      </li>

      <li>
        <p>Estimated average width (in bytes) of rows output by
        this plan node</p>
      </li>
    </ul>

    <p>The costs are measured in units of disk page fetches; that
    is, 1.0 equals one sequential disk page read, by definition.
    (CPU effort estimates are made too; they are converted into
    disk-page units using some fairly arbitrary fudge factors. If
    you want to experiment with these factors, see the list of
    run-time configuration parameters in <a href=
    "runtime-config-query.html#RUNTIME-CONFIG-QUERY-CONSTANTS">Section
    17.6.2</a>.)</p>

    <p>It's important to note that the cost of an upper-level node
    includes the cost of all its child nodes. It's also important
    to realize that the cost only reflects things that the planner
    cares about. In particular, the cost does not consider the time
    spent transmitting result rows to the client, which could be an
    important factor in the true elapsed time; but the planner
    ignores it because it cannot change it by altering the plan.
    (Every correct plan will output the same row set, we
    trust.)</p>

    <p>Rows output is a little tricky because it is <span class=
    "emphasis EMPHASIS c4">not</span> the number of rows processed
    or scanned by the plan node. It is usually less, reflecting the
    estimated selectivity of any <tt class=
    "LITERAL">WHERE</tt>-clause conditions that are being applied
    at the node. Ideally the top-level rows estimate will
    approximate the number of rows actually returned, updated, or
    deleted by the query.</p>

    <p>Returning to our example:</p>
    <pre class="PROGRAMLISTING">
EXPLAIN SELECT * FROM tenk1;

                         QUERY PLAN
-------------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..458.00 rows=10000 width=244)
</pre>

    <p>This is about as straightforward as it gets. If you do</p>
    <pre class="PROGRAMLISTING">
SELECT relpages, reltuples FROM pg_class WHERE relname = 'tenk1';
</pre>

    <p>you will find out that <code class="CLASSNAME">tenk1</code>
    has 358 disk pages and 10000 rows. So the cost is estimated at
    358 page reads, defined as costing 1.0 apiece, plus 10000 *
    <a href=
    "runtime-config-query.html#GUC-CPU-TUPLE-COST">cpu_tuple_cost</a>
    which is typically 0.01 (try <tt class="COMMAND">SHOW
    cpu_tuple_cost</tt>).</p>

    <p>Now let's modify the query to add a <tt class=
    "LITERAL">WHERE</tt> condition:</p>
    <pre class="PROGRAMLISTING">
EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 7000;

                         QUERY PLAN
------------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..483.00 rows=7033 width=244)
   Filter: (unique1 &lt; 7000)
</pre>

    <p>Notice that the <tt class="COMMAND">EXPLAIN</tt> output
    shows the <tt class="LITERAL">WHERE</tt> clause being applied
    as a <span class="QUOTE">"filter"</span> condition; this means
    that the plan node checks the condition for each row it scans,
    and outputs only the ones that pass the condition. The estimate
    of output rows has gone down because of the <tt class=
    "LITERAL">WHERE</tt> clause. However, the scan will still have
    to visit all 10000 rows, so the cost hasn't decreased; in fact
    it has gone up a bit to reflect the extra CPU time spent
    checking the <tt class="LITERAL">WHERE</tt> condition.</p>

    <p>The actual number of rows this query would select is 7000,
    but the rows estimate is only approximate. If you try to
    duplicate this experiment, you will probably get a slightly
    different estimate; moreover, it will change after each
    <tt class="COMMAND">ANALYZE</tt> command, because the
    statistics produced by <tt class="COMMAND">ANALYZE</tt> are
    taken from a randomized sample of the table.</p>

    <p>Now, let's make the condition more restrictive:</p>
    <pre class="PROGRAMLISTING">
EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 100;

                                  QUERY PLAN
------------------------------------------------------------------------------
 Bitmap Heap Scan on tenk1  (cost=2.37..232.35 rows=106 width=244)
   Recheck Cond: (unique1 &lt; 100)
   -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..2.37 rows=106 width=0)
         Index Cond: (unique1 &lt; 100)
</pre>

    <p>Here the planner has decided to use a two-step plan: the
    bottom plan node visits an index to find the locations of rows
    matching the index condition, and then the upper plan node
    actually fetches those rows from the table itself. Fetching the
    rows separately is much more expensive than sequentially
    reading them, but because not all the pages of the table have
    to be visited, this is still cheaper than a sequential scan.
    (The reason for using two levels of plan is that the upper plan
    node sorts the row locations identified by the index into
    physical order before reading them, so as to minimize the costs
    of the separate fetches. The <span class=
    "QUOTE">"bitmap"</span> mentioned in the node names is the
    mechanism that does the sorting.)</p>

    <p>If the <tt class="LITERAL">WHERE</tt> condition is selective
    enough, the planner may switch to a <span class=
    "QUOTE">"simple"</span> index scan plan:</p>
    <pre class="PROGRAMLISTING">
EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 3;

                                  QUERY PLAN
------------------------------------------------------------------------------
 Index Scan using tenk1_unique1 on tenk1  (cost=0.00..10.00 rows=2 width=244)
   Index Cond: (unique1 &lt; 3)
</pre>

    <p>In this case the table rows are fetched in index order,
    which makes them even more expensive to read, but there are so
    few that the extra cost of sorting the row locations is not
    worth it. You'll most often see this plan type for queries that
    fetch just a single row, and for queries that request an
    <tt class="LITERAL">ORDER BY</tt> condition that matches the
    index order.</p>

    <p>Add another condition to the <tt class="LITERAL">WHERE</tt>
    clause:</p>
    <pre class="PROGRAMLISTING">
EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 3 AND stringu1 = 'xxx';

                                  QUERY PLAN
------------------------------------------------------------------------------
 Index Scan using tenk1_unique1 on tenk1  (cost=0.00..10.01 rows=1 width=244)
   Index Cond: (unique1 &lt; 3)
   Filter: (stringu1 = 'xxx'::name)
</pre>

    <p>The added condition <tt class="LITERAL">stringu1 =
    'xxx'</tt> reduces the output-rows estimate, but not the cost
    because we still have to visit the same set of rows. Notice
    that the <tt class="LITERAL">stringu1</tt> clause cannot be
    applied as an index condition (since this index is only on the
    <tt class="LITERAL">unique1</tt> column). Instead it is applied
    as a filter on the rows retrieved by the index. Thus the cost
    has actually gone up a little bit to reflect this extra
    checking.</p>

    <p>If there are indexes on several columns used in <tt class=
    "LITERAL">WHERE</tt>, the planner might choose to use an AND or
    OR combination of the indexes:</p>
    <pre class="PROGRAMLISTING">
EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND unique2 &gt; 9000;

                                     QUERY PLAN
-------------------------------------------------------------------------------------
 Bitmap Heap Scan on tenk1  (cost=11.27..49.11 rows=11 width=244)
   Recheck Cond: ((unique1 &lt; 100) AND (unique2 &gt; 9000))
   -&gt;  BitmapAnd  (cost=11.27..11.27 rows=11 width=0)
         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..2.37 rows=106 width=0)
               Index Cond: (unique1 &lt; 100)
         -&gt;  Bitmap Index Scan on tenk1_unique2  (cost=0.00..8.65 rows=1042 width=0)
               Index Cond: (unique2 &gt; 9000)
</pre>

    <p>But this requires visiting both indexes, so it's not
    necessarily a win compared to using just one index and treating
    the other condition as a filter. If you vary the ranges
    involved you'll see the plan change accordingly.</p>

    <p>Let's try joining two tables, using the columns we have been
    discussing:</p>
    <pre class="PROGRAMLISTING">
EXPLAIN SELECT * FROM tenk1 t1, tenk2 t2 WHERE t1.unique1 &lt; 100 AND t1.unique2 = t2.unique2;

                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Nested Loop  (cost=2.37..553.11 rows=106 width=488)
   -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=2.37..232.35 rows=106 width=244)
         Recheck Cond: (unique1 &lt; 100)
         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..2.37 rows=106 width=0)
               Index Cond: (unique1 &lt; 100)
   -&gt;  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.00..3.01 rows=1 width=244)
         Index Cond: ("outer".unique2 = t2.unique2)
</pre>

    <p>In this nested-loop join, the outer scan is the same bitmap
    index scan we saw earlier, and so its cost and row count are
    the same because we are applying the <tt class=
    "LITERAL">WHERE</tt> clause <tt class="LITERAL">unique1 &lt;
    100</tt> at that node. The <tt class="LITERAL">t1.unique2 =
    t2.unique2</tt> clause is not relevant yet, so it doesn't
    affect row count of the outer scan. For the inner scan, the
    <tt class="LITERAL">unique2</tt> value of the current
    outer-scan row is plugged into the inner index scan to produce
    an index condition like <tt class="LITERAL">t2.unique2 =
    <tt class="REPLACEABLE c5">constant</tt></tt>. So we get the
    same inner-scan plan and costs that we'd get from, say,
    <tt class="LITERAL">EXPLAIN SELECT * FROM tenk2 WHERE unique2 =
    42</tt>. The costs of the loop node are then set on the basis
    of the cost of the outer scan, plus one repetition of the inner
    scan for each outer row (106 * 3.01, here), plus a little CPU
    time for join processing.</p>

    <p>In this example the join's output row count is the same as
    the product of the two scans' row counts, but that's not true
    in general, because in general you can have <tt class=
    "LITERAL">WHERE</tt> clauses that mention both tables and so
    can only be applied at the join point, not to either input
    scan. For example, if we added <tt class="LITERAL">WHERE ...
    AND t1.hundred &lt; t2.hundred</tt>, that would decrease the
    output row count of the join node, but not change either input
    scan.</p>

    <p>One way to look at variant plans is to force the planner to
    disregard whatever strategy it thought was the winner, using
    the enable/disable flags described in <a href=
    "runtime-config-query.html#RUNTIME-CONFIG-QUERY-ENABLE">Section
    17.6.1</a>. (This is a crude tool, but useful. See also
    <a href="explicit-joins.html">Section 13.3</a>.)</p>
    <pre class="PROGRAMLISTING">
SET enable_nestloop = off;
EXPLAIN SELECT * FROM tenk1 t1, tenk2 t2 WHERE t1.unique1 &lt; 100 AND t1.unique2 = t2.unique2;

                                        QUERY PLAN
------------------------------------------------------------------------------------------
 Hash Join  (cost=232.61..741.67 rows=106 width=488)
   Hash Cond: ("outer".unique2 = "inner".unique2)
   -&gt;  Seq Scan on tenk2 t2  (cost=0.00..458.00 rows=10000 width=244)
   -&gt;  Hash  (cost=232.35..232.35 rows=106 width=244)
         -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=2.37..232.35 rows=106 width=244)
               Recheck Cond: (unique1 &lt; 100)
               -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..2.37 rows=106 width=0)
                     Index Cond: (unique1 &lt; 100)
</pre>

    <p>This plan proposes to extract the 100 interesting rows of
    <code class="CLASSNAME">tenk1</code> using that same old index
    scan, stash them into an in-memory hash table, and then do a
    sequential scan of <code class="CLASSNAME">tenk2</code>,
    probing into the hash table for possible matches of <tt class=
    "LITERAL">t1.unique2 = t2.unique2</tt> at each <code class=
    "CLASSNAME">tenk2</code> row. The cost to read <code class=
    "CLASSNAME">tenk1</code> and set up the hash table is entirely
    start-up cost for the hash join, since we won't get any rows
    out until we can start reading <code class=
    "CLASSNAME">tenk2</code>. The total time estimate for the join
    also includes a hefty charge for the CPU time to probe the hash
    table 10000 times. Note, however, that we are <span class=
    "emphasis EMPHASIS c4">not</span> charging 10000 times 232.35;
    the hash table setup is only done once in this plan type.</p>

    <p>It is possible to check on the accuracy of the planner's
    estimated costs by using <tt class="COMMAND">EXPLAIN
    ANALYZE</tt>. This command actually executes the query, and
    then displays the true run time accumulated within each plan
    node along with the same estimated costs that a plain
    <tt class="COMMAND">EXPLAIN</tt> shows. For example, we might
    get a result like this:</p>
    <pre class="SCREEN">
EXPLAIN ANALYZE SELECT * FROM tenk1 t1, tenk2 t2 WHERE t1.unique1 &lt; 100 AND t1.unique2 = t2.unique2;

                                                            QUERY PLAN
----------------------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=2.37..553.11 rows=106 width=488) (actual time=1.392..12.700 rows=100 loops=1)
   -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=2.37..232.35 rows=106 width=244) (actual time=0.878..2.367 rows=100 loops=1)
         Recheck Cond: (unique1 &lt; 100)
         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..2.37 rows=106 width=0) (actual time=0.546..0.546 rows=100 loops=1)
               Index Cond: (unique1 &lt; 100)
   -&gt;  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.00..3.01 rows=1 width=244) (actual time=0.067..0.078 rows=1 loops=100)
         Index Cond: ("outer".unique2 = t2.unique2)
 Total runtime: 14.452 ms
</pre>

    <p>Note that the <span class="QUOTE">"actual time"</span>
    values are in milliseconds of real time, whereas the
    <span class="QUOTE">"cost"</span> estimates are expressed in
    arbitrary units of disk fetches; so they are unlikely to match
    up. The thing to pay attention to is the ratios.</p>

    <p>In some query plans, it is possible for a subplan node to be
    executed more than once. For example, the inner index scan is
    executed once per outer row in the above nested-loop plan. In
    such cases, the <span class="QUOTE">"loops"</span> value
    reports the total number of executions of the node, and the
    actual time and rows values shown are averages per-execution.
    This is done to make the numbers comparable with the way that
    the cost estimates are shown. Multiply by the <span class=
    "QUOTE">"loops"</span> value to get the total time actually
    spent in the node.</p>

    <p>The <tt class="LITERAL">Total runtime</tt> shown by
    <tt class="COMMAND">EXPLAIN ANALYZE</tt> includes executor
    start-up and shut-down time, as well as time spent processing
    the result rows. It does not include parsing, rewriting, or
    planning time. For a <tt class="COMMAND">SELECT</tt> query, the
    total run time will normally be just a little larger than the
    total time reported for the top-level plan node. For <tt class=
    "COMMAND">INSERT</tt>, <tt class="COMMAND">UPDATE</tt>, and
    <tt class="COMMAND">DELETE</tt> commands, the total run time
    may be considerably larger, because it includes the time spent
    processing the result rows. In these commands, the time for the
    top plan node essentially is the time spent computing the new
    rows and/or locating the old ones, but it doesn't include the
    time spent making the changes. Time spent firing triggers, if
    any, is also outside the top plan node, and is shown separately
    for each trigger.</p>

    <p>It is worth noting that <tt class="COMMAND">EXPLAIN</tt>
    results should not be extrapolated to situations other than the
    one you are actually testing; for example, results on a
    toy-sized table can't be assumed to apply to large tables. The
    planner's cost estimates are not linear and so it may well
    choose a different plan for a larger or smaller table. An
    extreme example is that on a table that only occupies one disk
    page, you'll nearly always get a sequential scan plan whether
    indexes are available or not. The planner realizes that it's
    going to take one disk page read to process the table in any
    case, so there's no value in expending additional page reads to
    look at an index.</p>
  </div>
</div>

<h3 class="FOOTNOTES">Notes</h3>

<table border="0" class="FOOTNOTES" width="100%">
  <tr>
    <td align="left" valign="top" width="5%"><a name="FTN.AEN15700"
    href="performance-tips.html#AEN15700" id=
    "FTN.AEN15700"><span class="footnote">[1]</span></a></td>

    <td align="left" valign="top" width="95%">
      <p>Examples in this section are drawn from the regression
      test database after doing a <tt class="COMMAND">VACUUM
      ANALYZE</tt>, using 8.1 development sources. You should be
      able to get similar results if you try the examples yourself,
      but your estimated costs and row counts will probably vary
      slightly because <tt class="COMMAND">ANALYZE</tt>'s
      statistics are random samples rather than being exact.</p>
    </td>
  </tr>
</table>

<div class="NAVFOOTER">
  <hr class="c1" width="100%" />

  <table summary="Footer navigation table" width="100%" border="0"
  cellpadding="0" cellspacing="0">
    <tr>
      <td width="33%" align="left" valign="top"><a href=
      "locking-indexes.html" accesskey="P">Prev</a></td>

      <td width="34%" align="center" valign="top"><a href=
      "index.html" accesskey="H">Home</a></td>

      <td width="33%" align="right" valign="top"><a href=
      "planner-stats.html" accesskey="N">Next</a></td>
    </tr>

    <tr>
      <td width="33%" align="left" valign="top">Locking and
      Indexes</td>

      <td width="34%" align="center" valign="top"><a href=
      "sql.html" accesskey="U">Up</a></td>

      <td width="33%" align="right" valign="top">Statistics Used by
      the Planner</td>
    </tr>
  </table>
</div>

          </div>
          
        </div> <!-- pgContentWrap -->
      </div>
    </div>

    <!-- Footer -->
    <footer id="footer">
      <!-- Copyright -->
      <div class="container">
        <a href="/about/policies/">Policies</a> |
        <a href="/about/policies/coc/">Code of Conduct</a> |
        <a href="/about/">About PostgreSQL</a> |
        <a href="/about/contact/">Contact</a><br/>
        <p>Copyright &copy; 1996-2026 The PostgreSQL Global Development Group</p>
      </div>
    </footer>
    <script src="/media/js/main.js?77152761"></script>

  </body>
</html>
