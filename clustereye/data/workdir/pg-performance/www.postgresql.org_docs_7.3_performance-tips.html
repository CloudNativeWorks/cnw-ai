<!doctype html>
<html lang="en">
 <head>
  <title>PostgreSQL: Documentation: 7.3: Performance Tips</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta http-equiv="Content-Type" content="text/xhtml; charset=utf-8" />
   
  <meta name="theme-color" content="#336791"/>
  <meta name="copyright" content="The PostgreSQL Global Development Group" />
  <meta property="og:url" content="https://www.postgresql.org/docs/7.3/performance-tips.html" />
  <meta property="og:type" content="article" />

  <meta property="article:published_time" content="2012-01-01T00:00:00" />
  <meta property="og:image" content="https://www.postgresql.org/media/img/about/press/elephant.png" />
  <meta property="og:title" content="Performance Tips" />
  <meta property="og:description" content="" />
  <meta property="og:site_name" content="PostgreSQL Documentation" />
  <link href="/media/css/fontawesome.css?77152761" rel="stylesheet">
  <link rel="stylesheet" href="/media/css/bootstrap-4.4.1.min.css">
  <link rel="shortcut icon" href="/favicon.ico" />
  
  <link rel="stylesheet" type="text/css" href="/dyncss/base.css?77152761">

  <script src="/media/js/theme.js?77152761"></script>

  
  <meta name="robots" content="nofollow" />

  <link rel="canonical" href="https://www.postgresql.org/docs/current/performance-tips.html" />


  </head>
  <body>
    <div class="container-fluid">
      <div class="row justify-content-md-center">
        <div class="col">
          <!-- Header -->
          <nav class="navbar navbar-expand-lg navbar-light bg-light">
            <a class="navbar-brand p-0" href="/">
              <img class="logo" src="/media/img/about/press/elephant.png" alt="PostgreSQL Elephant Logo">
            </a>
            <input type="checkbox" id="navbar-toggler" aria-controls="pgNavbar" aria-expanded="false" aria-label="Toggle navigation">
            <label for="navbar-toggler" id="navbar-toggler-label" class="navbar-toggler" tabindex="0"><span class="navbar-toggler-icon"></span></label>
            <div class="navbar-collapse" id="pgNavbar">
              <ul class="navbar-nav mr-auto">
                <li class="nav-item p-2"><a href="/" title="Home">Home</a></li>
                <li class="nav-item p-2"><a href="/about/" title="About">About</a></li>
                <li class="nav-item p-2"><a href="/download/" title="Download">Download</a></li>
                <li class="nav-item p-2"><a href="/docs/" title="Documentation">Documentation</a></li>
                <li class="nav-item p-2"><a href="/community/" title="Community">Community</a></li>
                <li class="nav-item p-2"><a href="/developer/" title="Developers">Developers</a></li>
                <li class="nav-item p-2"><a href="/support/" title="Support">Support</a></li>
                <li class="nav-item p-2"><a href="/about/donate/" title="Donate">Donate</a></li>
                <li class="nav-item p-2"><a href="/account/" title="Your account">Your account</a></li>
              </ul>
              <form role="search" method="get" action="/search/">
                <div class="input-group">
                  <input id="q" name="q" type="text" size="20" maxlength="255" accesskey="s"  class="form-control" placeholder="Search for...">
                  <span class="input-group-btn">
                    <button class="btn btn-default" type="submit"><i class="fas fa-search"></i></button>
                  </span>
                </div><!-- /input-group -->
              </form>
              <form id="form-theme" class="form-inline d-none">
                <button id="btn-theme" class="btn btn-default ml-1" type="button"></button>
              </form>
            </div>
          </nav>
        </div>
      </div>
      <div class="row justify-content-center pg-shout-box">
        <div class="col text-white text-center">February 16, 2026: <a href="/about/news/out-of-cycle-release-scheduled-for-february-26-2026-3241/">
  Out-of-cycle release scheduled for February 26, 2026
</a>
</div>
      </div>
    </div>
    
    <div class="container-fluid margin">
      <div class="row">
        <div id="pgContentWrap" class="col-11">
          <div class="row">
            <div class="col-md-6 mb-2">
              <div class="row">
                <div class="col">
                  <div>
                    <a href="/docs/" title="Documentation">Documentation</a> &rarr; <a href="/docs/7.3/index.html">PostgreSQL 7.3</a>
                  </div>
                </div>
              </div>
              
                <div class="row">
                  <div class="col">
                    Supported Versions:
                      
                        
                        
                          <a href="/docs/current/performance-tips.html" title="PostgreSQL 18 - Performance Tips" >Current</a>
                          (<a href="/docs/18/performance-tips.html" title="PostgreSQL 18 - Performance Tips" >18</a>)
                        
                      
                         / 
                        
                          <a href="/docs/17/performance-tips.html" title="PostgreSQL 17 - Performance Tips" >17</a>
                        
                      
                         / 
                        
                          <a href="/docs/16/performance-tips.html" title="PostgreSQL 16 - Performance Tips" >16</a>
                        
                      
                         / 
                        
                          <a href="/docs/15/performance-tips.html" title="PostgreSQL 15 - Performance Tips" >15</a>
                        
                      
                         / 
                        
                          <a href="/docs/14/performance-tips.html" title="PostgreSQL 14 - Performance Tips" >14</a>
                        
                      
                  </div>
                </div>
              
              
                <div class="row">
                  <div class="col">
                    Development Versions:
                    
                      
                      <a href="/docs/devel/performance-tips.html" title="PostgreSQL devel - Performance Tips"  rel="nofollow">devel</a>
                    
                  </div>
                </div>
              
              
                <div class="row">
                  <div class="col-12">
                    Unsupported versions:
                    
                      
                      <a href="/docs/13/performance-tips.html" title="PostgreSQL 13 - Performance Tips"  rel="nofollow">13</a>
                    
                       / 
                      <a href="/docs/12/performance-tips.html" title="PostgreSQL 12 - Performance Tips"  rel="nofollow">12</a>
                    
                       / 
                      <a href="/docs/11/performance-tips.html" title="PostgreSQL 11 - Performance Tips"  rel="nofollow">11</a>
                    
                       / 
                      <a href="/docs/10/performance-tips.html" title="PostgreSQL 10 - Performance Tips"  rel="nofollow">10</a>
                    
                       / 
                      <a href="/docs/9.6/performance-tips.html" title="PostgreSQL 9.6 - Performance Tips"  rel="nofollow">9.6</a>
                    
                       / 
                      <a href="/docs/9.5/performance-tips.html" title="PostgreSQL 9.5 - Performance Tips"  rel="nofollow">9.5</a>
                    
                       / 
                      <a href="/docs/9.4/performance-tips.html" title="PostgreSQL 9.4 - Performance Tips"  rel="nofollow">9.4</a>
                    
                       / 
                      <a href="/docs/9.3/performance-tips.html" title="PostgreSQL 9.3 - Performance Tips"  rel="nofollow">9.3</a>
                    
                       / 
                      <a href="/docs/9.2/performance-tips.html" title="PostgreSQL 9.2 - Performance Tips"  rel="nofollow">9.2</a>
                    
                       / 
                      <a href="/docs/9.1/performance-tips.html" title="PostgreSQL 9.1 - Performance Tips"  rel="nofollow">9.1</a>
                    
                       / 
                      <a href="/docs/9.0/performance-tips.html" title="PostgreSQL 9.0 - Performance Tips"  rel="nofollow">9.0</a>
                    
                       / 
                      <a href="/docs/8.4/performance-tips.html" title="PostgreSQL 8.4 - Performance Tips"  rel="nofollow">8.4</a>
                    
                       / 
                      <a href="/docs/8.3/performance-tips.html" title="PostgreSQL 8.3 - Performance Tips"  rel="nofollow">8.3</a>
                    
                       / 
                      <a href="/docs/8.2/performance-tips.html" title="PostgreSQL 8.2 - Performance Tips"  rel="nofollow">8.2</a>
                    
                       / 
                      <a href="/docs/8.1/performance-tips.html" title="PostgreSQL 8.1 - Performance Tips"  rel="nofollow">8.1</a>
                    
                       / 
                      <a href="/docs/8.0/performance-tips.html" title="PostgreSQL 8.0 - Performance Tips"  rel="nofollow">8.0</a>
                    
                       / 
                      <a href="/docs/7.4/performance-tips.html" title="PostgreSQL 7.4 - Performance Tips"  rel="nofollow">7.4</a>
                    
                       / 
                      <a href="/docs/7.3/performance-tips.html" title="PostgreSQL 7.3 - Performance Tips" class="docs-version-selected" rel="nofollow">7.3</a>
                    
                       / 
                      <a href="/docs/7.2/performance-tips.html" title="PostgreSQL 7.2 - Performance Tips"  rel="nofollow">7.2</a>
                    
                       / 
                      <a href="/docs/7.1/performance-tips.html" title="PostgreSQL 7.1 - Performance Tips"  rel="nofollow">7.1</a>
                    
                  </div>
                </div>
              
            </div>
            <div class="col-md-6 col-lg-5 offset-lg-1">
              <form id="docSearchForm" role="search" method="get" action="/search/">
                <input type="hidden" name="u" value="/docs/7.3/" />
                <div class="input-group">
                  <input type="text" id="q" name="q" class="form-control" placeholder="Search the documentation for..."/>
                  <span class="input-group-btn">
                    <button class="btn btn-default" type="submit"><i class="fas fa-search"></i></button>
                  </span>
                </div><!-- /input-group -->
              </form>
            </div>
          </div>

	  <div class="text-center alert-warning">
	    This documentation is for an unsupported version of PostgreSQL.<br/>
	    You may want to view the same page for the
	    <a href="/docs/current/performance-tips.html" title="PostgreSQL  - Performance Tips">current</a>
	    version, or one of the other supported versions listed above instead.
	  </div>

          <div id="docContent">
            <div class="NAVHEADER">
  <table summary="Header navigation table" width="100%" border="0"
  cellpadding="0" cellspacing="0">
    <tr>
      <th colspan="3" align="center">PostgreSQL 7.3.21
      Documentation</th>
    </tr>

    <tr>
      <td width="10%" align="left" valign="bottom"><a href=
      "locking-indexes.html" accesskey="P">Prev</a></td>

      <td width="80%" align="center" valign="bottom"></td>

      <td width="10%" align="right" valign="bottom"><a href=
      "planner-stats.html" accesskey="N">Next</a></td>
    </tr>
  </table>
  <hr class="c1" width="100%" />
</div>

<div class="CHAPTER">
  <h1><a name="PERFORMANCE-TIPS" id="PERFORMANCE-TIPS"></a>Chapter
  10. Performance Tips</h1>

  <div class="TOC">
    <dl>
      <dt class="c2">Table of Contents</dt>

      <dt>10.1. <a href="performance-tips.html#USING-EXPLAIN">Using
      <tt class="COMMAND">EXPLAIN</tt></a></dt>

      <dt>10.2. <a href="planner-stats.html">Statistics Used by the
      Planner</a></dt>

      <dt>10.3. <a href="explicit-joins.html">Controlling the
      Planner with Explicit <tt class="LITERAL">JOIN</tt>
      Clauses</a></dt>

      <dt>10.4. <a href="populate.html">Populating a
      Database</a></dt>

      <dd>
        <dl>
          <dt>10.4.1. <a href=
          "populate.html#DISABLE-AUTOCOMMIT">Disable
          Autocommit</a></dt>

          <dt>10.4.2. <a href=
          "populate.html#POPULATE-COPY-FROM">Use COPY FROM</a></dt>

          <dt>10.4.3. <a href=
          "populate.html#POPULATE-RM-INDEXES">Remove
          Indexes</a></dt>

          <dt>10.4.4. <a href="populate.html#POPULATE-ANALYZE">Run
          ANALYZE Afterwards</a></dt>
        </dl>
      </dd>
    </dl>
  </div>

  <p>Query performance can be affected by many things. Some of
  these can be manipulated by the user, while others are
  fundamental to the underlying design of the system. This chapter
  provides some hints about understanding and tuning <span class=
  "PRODUCTNAME">PostgreSQL</span> performance.</p>

  <div class="SECT1">
    <h1 class="SECT1"><a name="USING-EXPLAIN" id=
    "USING-EXPLAIN">10.1. Using <tt class=
    "COMMAND">EXPLAIN</tt></a></h1>

    <p><span class="PRODUCTNAME">PostgreSQL</span> devises a
    <i class="FIRSTTERM">query plan</i> for each query it is given.
    Choosing the right plan to match the query structure and the
    properties of the data is absolutely critical for good
    performance. You can use the <tt class="COMMAND">EXPLAIN</tt>
    command to see what query plan the system creates for any
    query. Plan-reading is an art that deserves an extensive
    tutorial, which this is not; but here is some basic
    information.</p>

    <p>The numbers that are currently quoted by <tt class=
    "COMMAND">EXPLAIN</tt> are:</p>

    <ul>
      <li>
        <p>Estimated start-up cost (Time expended before output
        scan can start, e.g., time to do the sorting in a sort
        node.)</p>
      </li>

      <li>
        <p>Estimated total cost (If all rows are retrieved, which
        they may not be --- a query with a <tt class=
        "LITERAL">LIMIT</tt> clause will stop short of paying the
        total cost, for example.)</p>
      </li>

      <li>
        <p>Estimated number of rows output by this plan node
        (Again, only if executed to completion.)</p>
      </li>

      <li>
        <p>Estimated average width (in bytes) of rows output by
        this plan node</p>
      </li>
    </ul>

    <p>The costs are measured in units of disk page fetches. (CPU
    effort estimates are converted into disk-page units using some
    fairly arbitrary fudge factors. If you want to experiment with
    these factors, see the list of run-time configuration
    parameters in the <a class="c3" href="admin.html">PostgreSQL
    7.3.21 Administrator's Guide</a>.)</p>

    <p>It's important to note that the cost of an upper-level node
    includes the cost of all its child nodes. It's also important
    to realize that the cost only reflects things that the
    planner/optimizer cares about. In particular, the cost does not
    consider the time spent transmitting result rows to the
    frontend --- which could be a pretty dominant factor in the
    true elapsed time, but the planner ignores it because it cannot
    change it by altering the plan. (Every correct plan will output
    the same row set, we trust.)</p>

    <p>Rows output is a little tricky because it is <span class=
    "emphasis EMPHASIS c4">not</span> the number of rows
    processed/scanned by the query --- it is usually less,
    reflecting the estimated selectivity of any <tt class=
    "LITERAL">WHERE</tt>-clause constraints that are being applied
    at this node. Ideally the top-level rows estimate will
    approximate the number of rows actually returned, updated, or
    deleted by the query.</p>

    <p>Here are some examples (using the regress test database
    after a <tt class="LITERAL">VACUUM ANALYZE</tt>, and 7.3
    development sources):</p>
    <pre class="PROGRAMLISTING">
regression=# EXPLAIN SELECT * FROM tenk1;
                         QUERY PLAN
-------------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..333.00 rows=10000 width=148)
</pre>

    <p>This is about as straightforward as it gets. If you do</p>
    <pre class="PROGRAMLISTING">
SELECT * FROM pg_class WHERE relname = 'tenk1';
</pre>

    <p>you will find out that <code class="CLASSNAME">tenk1</code>
    has 233 disk pages and 10000 rows. So the cost is estimated at
    233 page reads, defined as costing 1.0 apiece, plus 10000 *
    <code class="VARNAME">cpu_tuple_cost</code> which is currently
    0.01 (try <tt class="COMMAND">SHOW cpu_tuple_cost</tt>).</p>

    <p>Now let's modify the query to add a <tt class=
    "LITERAL">WHERE</tt> condition:</p>
    <pre class="PROGRAMLISTING">
regression=# EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 1000;
                         QUERY PLAN
------------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..358.00 rows=1033 width=148)
   Filter: (unique1 &lt; 1000)
</pre>

    <p>The estimate of output rows has gone down because of the
    <tt class="LITERAL">WHERE</tt> clause. However, the scan will
    still have to visit all 10000 rows, so the cost hasn't
    decreased; in fact it has gone up a bit to reflect the extra
    CPU time spent checking the <tt class="LITERAL">WHERE</tt>
    condition.</p>

    <p>The actual number of rows this query would select is 1000,
    but the estimate is only approximate. If you try to duplicate
    this experiment, you will probably get a slightly different
    estimate; moreover, it will change after each <tt class=
    "COMMAND">ANALYZE</tt> command, because the statistics produced
    by <tt class="COMMAND">ANALYZE</tt> are taken from a randomized
    sample of the table.</p>

    <p>Modify the query to restrict the condition even more:</p>
    <pre class="PROGRAMLISTING">
regression=# EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 50;
                                   QUERY PLAN
-------------------------------------------------------------------------------
 Index Scan using tenk1_unique1 on tenk1  (cost=0.00..179.33 rows=49 width=148)
   Index Cond: (unique1 &lt; 50)
</pre>

    <p>and you will see that if we make the <tt class=
    "LITERAL">WHERE</tt> condition selective enough, the planner
    will eventually decide that an index scan is cheaper than a
    sequential scan. This plan will only have to visit 50 rows
    because of the index, so it wins despite the fact that each
    individual fetch is more expensive than reading a whole disk
    page sequentially.</p>

    <p>Add another clause to the <tt class="LITERAL">WHERE</tt>
    condition:</p>
    <pre class="PROGRAMLISTING">
regression=# EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 50 AND
regression-# stringu1 = 'xxx';
                                  QUERY PLAN
-------------------------------------------------------------------------------
 Index Scan using tenk1_unique1 on tenk1  (cost=0.00..179.45 rows=1 width=148)
   Index Cond: (unique1 &lt; 50)
   Filter: (stringu1 = 'xxx'::name)
</pre>

    <p>The added clause <tt class="LITERAL">stringu1 = 'xxx'</tt>
    reduces the output-rows estimate, but not the cost because we
    still have to visit the same set of rows. Notice that the
    <tt class="LITERAL">stringu1</tt> clause cannot be applied as
    an index condition (since this index is only on the <tt class=
    "LITERAL">unique1</tt> column). Instead it is applied as a
    filter on the rows retrieved by the index. Thus the cost has
    actually gone up a little bit to reflect this extra
    checking.</p>

    <p>Let's try joining two tables, using the fields we have been
    discussing:</p>
    <pre class="PROGRAMLISTING">
regression=# EXPLAIN SELECT * FROM tenk1 t1, tenk2 t2 WHERE t1.unique1 &lt; 50
regression-# AND t1.unique2 = t2.unique2;
                               QUERY PLAN
----------------------------------------------------------------------------
 Nested Loop  (cost=0.00..327.02 rows=49 width=296)
   -&gt;  Index Scan using tenk1_unique1 on tenk1 t1
                                      (cost=0.00..179.33 rows=49 width=148)
         Index Cond: (unique1 &lt; 50)
   -&gt;  Index Scan using tenk2_unique2 on tenk2 t2
                                      (cost=0.00..3.01 rows=1 width=148)
         Index Cond: ("outer".unique2 = t2.unique2)
</pre>

    <p>In this nested-loop join, the outer scan is the same index
    scan we had in the example before last, and so its cost and row
    count are the same because we are applying the <tt class=
    "LITERAL">unique1 &lt; 50</tt> <tt class="LITERAL">WHERE</tt>
    clause at that node. The <tt class="LITERAL">t1.unique2 =
    t2.unique2</tt> clause is not relevant yet, so it doesn't
    affect row count of the outer scan. For the inner scan, the
    <tt class="LITERAL">unique2</tt> value of the current
    outer-scan row is plugged into the inner index scan to produce
    an index condition like <tt class="LITERAL">t2.unique2 =
    <tt class="REPLACEABLE c5">constant</tt></tt>. So we get the
    same inner-scan plan and costs that we'd get from, say,
    <tt class="LITERAL">EXPLAIN SELECT * FROM tenk2 WHERE unique2 =
    42</tt>. The costs of the loop node are then set on the basis
    of the cost of the outer scan, plus one repetition of the inner
    scan for each outer row (49 * 3.01, here), plus a little CPU
    time for join processing.</p>

    <p>In this example the loop's output row count is the same as
    the product of the two scans' row counts, but that's not true
    in general, because in general you can have <tt class=
    "LITERAL">WHERE</tt> clauses that mention both relations and so
    can only be applied at the join point, not to either input
    scan. For example, if we added <tt class="LITERAL">WHERE ...
    AND t1.hundred &lt; t2.hundred</tt>, that would decrease the
    output row count of the join node, but not change either input
    scan.</p>

    <p>One way to look at variant plans is to force the planner to
    disregard whatever strategy it thought was the winner, using
    the enable/disable flags for each plan type. (This is a crude
    tool, but useful. See also <a href=
    "explicit-joins.html">Section 10.3</a>.)</p>
    <pre class="PROGRAMLISTING">
regression=# SET enable_nestloop = off;
SET
regression=# EXPLAIN SELECT * FROM tenk1 t1, tenk2 t2 WHERE t1.unique1 &lt; 50
regression-# AND t1.unique2 = t2.unique2;
                               QUERY PLAN
--------------------------------------------------------------------------
 Hash Join  (cost=179.45..563.06 rows=49 width=296)
   Hash Cond: ("outer".unique2 = "inner".unique2)
   -&gt;  Seq Scan on tenk2 t2  (cost=0.00..333.00 rows=10000 width=148)
   -&gt;  Hash  (cost=179.33..179.33 rows=49 width=148)
         -&gt;  Index Scan using tenk1_unique1 on tenk1 t1
                                    (cost=0.00..179.33 rows=49 width=148)
               Index Cond: (unique1 &lt; 50)
</pre>

    <p>This plan proposes to extract the 50 interesting rows of
    <code class="CLASSNAME">tenk1</code> using ye same olde index
    scan, stash them into an in-memory hash table, and then do a
    sequential scan of <code class="CLASSNAME">tenk2</code>,
    probing into the hash table for possible matches of <tt class=
    "LITERAL">t1.unique2 = t2.unique2</tt> at each <code class=
    "CLASSNAME">tenk2</code> row. The cost to read <code class=
    "CLASSNAME">tenk1</code> and set up the hash table is entirely
    start-up cost for the hash join, since we won't get any rows
    out until we can start reading <code class=
    "CLASSNAME">tenk2</code>. The total time estimate for the join
    also includes a hefty charge for the CPU time to probe the hash
    table 10000 times. Note, however, that we are <span class=
    "emphasis EMPHASIS c4">not</span> charging 10000 times 179.33;
    the hash table setup is only done once in this plan type.</p>

    <p>It is possible to check on the accuracy of the planner's
    estimated costs by using <tt class="COMMAND">EXPLAIN
    ANALYZE</tt>. This command actually executes the query, and
    then displays the true run time accumulated within each plan
    node along with the same estimated costs that a plain
    <tt class="COMMAND">EXPLAIN</tt> shows. For example, we might
    get a result like this:</p>
    <pre class="SCREEN">
regression=# EXPLAIN ANALYZE
regression-# SELECT * FROM tenk1 t1, tenk2 t2
regression-# WHERE t1.unique1 &lt; 50 AND t1.unique2 = t2.unique2;
                                   QUERY PLAN
-------------------------------------------------------------------------------
 Nested Loop  (cost=0.00..327.02 rows=49 width=296)
                                 (actual time=1.18..29.82 rows=50 loops=1)
   -&gt;  Index Scan using tenk1_unique1 on tenk1 t1
                  (cost=0.00..179.33 rows=49 width=148)
                                 (actual time=0.63..8.91 rows=50 loops=1)
         Index Cond: (unique1 &lt; 50)
   -&gt;  Index Scan using tenk2_unique2 on tenk2 t2
                  (cost=0.00..3.01 rows=1 width=148)
                                 (actual time=0.29..0.32 rows=1 loops=50)
         Index Cond: ("outer".unique2 = t2.unique2)
 Total runtime: 31.60 msec
</pre>

    <p>Note that the <span class="QUOTE">"actual time"</span>
    values are in milliseconds of real time, whereas the
    <span class="QUOTE">"cost"</span> estimates are expressed in
    arbitrary units of disk fetches; so they are unlikely to match
    up. The thing to pay attention to is the ratios.</p>

    <p>In some query plans, it is possible for a subplan node to be
    executed more than once. For example, the inner index scan is
    executed once per outer row in the above nested-loop plan. In
    such cases, the <span class="QUOTE">"loops"</span> value
    reports the total number of executions of the node, and the
    actual time and rows values shown are averages per-execution.
    This is done to make the numbers comparable with the way that
    the cost estimates are shown. Multiply by the <span class=
    "QUOTE">"loops"</span> value to get the total time actually
    spent in the node.</p>

    <p>The <tt class="LITERAL">Total runtime</tt> shown by
    <tt class="COMMAND">EXPLAIN ANALYZE</tt> includes executor
    start-up and shut-down time, as well as time spent processing
    the result rows. It does not include parsing, rewriting, or
    planning time. For a <tt class="COMMAND">SELECT</tt> query, the
    total run time will normally be just a little larger than the
    total time reported for the top-level plan node. For <tt class=
    "COMMAND">INSERT</tt>, <tt class="COMMAND">UPDATE</tt>, and
    <tt class="COMMAND">DELETE</tt> commands, the total run time
    may be considerably larger, because it includes the time spent
    processing the result rows. In these commands, the time for the
    top plan node essentially is the time spent computing the new
    rows and/or locating the old ones, but it doesn't include the
    time spent making the changes.</p>

    <p>It is worth noting that <tt class="COMMAND">EXPLAIN</tt>
    results should not be extrapolated to situations other than the
    one you are actually testing; for example, results on a
    toy-sized table can't be assumed to apply to large tables. The
    planner's cost estimates are not linear and so it may well
    choose a different plan for a larger or smaller table. An
    extreme example is that on a table that only occupies one disk
    page, you'll nearly always get a sequential scan plan whether
    indexes are available or not. The planner realizes that it's
    going to take one disk page read to process the table in any
    case, so there's no value in expending additional page reads to
    look at an index.</p>
  </div>
</div>

<div class="NAVFOOTER">
  <hr class="c1" width="100%" />

  <table summary="Footer navigation table" width="100%" border="0"
  cellpadding="0" cellspacing="0">
    <tr>
      <td width="33%" align="left" valign="top"><a href=
      "locking-indexes.html" accesskey="P">Prev</a></td>

      <td width="34%" align="center" valign="top"><a href=
      "index.html" accesskey="H">Home</a></td>

      <td width="33%" align="right" valign="top"><a href=
      "planner-stats.html" accesskey="N">Next</a></td>
    </tr>

    <tr>
      <td width="33%" align="left" valign="top">Locking and
      Indexes</td>

      <td width="34%" align="center" valign="top"><a href=
      "user.html" accesskey="U">Up</a></td>

      <td width="33%" align="right" valign="top">Statistics Used by
      the Planner</td>
    </tr>
  </table>
</div>

          </div>
          
        </div> <!-- pgContentWrap -->
      </div>
    </div>

    <!-- Footer -->
    <footer id="footer">
      <!-- Copyright -->
      <div class="container">
        <a href="/about/policies/">Policies</a> |
        <a href="/about/policies/coc/">Code of Conduct</a> |
        <a href="/about/">About PostgreSQL</a> |
        <a href="/about/contact/">Contact</a><br/>
        <p>Copyright &copy; 1996-2026 The PostgreSQL Global Development Group</p>
      </div>
    </footer>
    <script src="/media/js/main.js?77152761"></script>

  </body>
</html>
